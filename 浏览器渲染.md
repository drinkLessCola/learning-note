## 线程 进程

**进程：一个程序的运行实例。**

- 启动一个程序的时候，操作系统会为该程序分配独立的内存空间，用于存放代码，运行中的数据和一个执行任务的主线程。
- 这样的一个运行环境叫做进程。
- 进程曾经是分时系统的基本运作单位。
  - 在面向进程设计的系统，进程是程序的基本**执行实体**。
  - 在面向线程设计的系统，<u>进程本身不是基本运行单位</u>，**而是线程的容器**。
- 现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时分复用，以在一个处理器上表现出同时运行的感觉。

**线程：是操作系统能够进行运行调度的最小单位。**

- 大部分情况下，它被包含在进程之中，是进程中的实际运作单位。
- **一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。**
- 线程是独立调度和分派的基本单位。
  - 可以为操作系统内核调度的内核线程，如 Win32 线程。
  - 由用户进程自行调度的用户线程，如 Linux 平台的 POSIX Thread
  - 或者由内核与用户进程进行混合调度，如 Windows 7 的线程。
- **同一个进程中的多个线程之间共享该进程中的全部系统资源**，如虚拟地址空间，文件描述符和信号处理等。
- 但同一进程中的多个线程有独立的**寄存器环境**，**调用栈** 和 **线程本地存储**。保证线程的控制流是相对独立的。

**进程与线程之间的关系：** 

- 进程中任意线程执行出错，都会导致整个进程的崩溃。
- 线程之间共享进程中的数据。



## 单进程浏览器

单进程浏览器是指浏览器的所有模块都运行在同一个进程里。

- 页面线程
  - 页面渲染、页面展现、<u>JavaScript 环境</u>、<u>插件</u>都运行在页面线程中。
- 网络线程
- 其他线程

这么多的功能模块运行在一个进程中，存在不足：

- 不稳定性
  - 一个线程出错，将导致整个浏览器进程（所有线程）崩溃。
- 不流畅
  - JavaScript 运行在页面线程中，脚本执行时间过长（脚本中有死循环）将会阻塞其他的任务，如页面渲染，造成不好的交互体验。
- 不安全
  - 线程之间会共享进程的数据，因此页面线程中的 JavaScript 脚本将可以读取 / 写入用户系统上的文件和数据。

## 多进程浏览器

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a069d7f27b6atplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

- 页面运行在单独的渲染进程之中
- 页面中的插件运行在单独的插件进程之中
- 进程之间通过 IPC 机制进行通信

#### 解决不稳定的问题：

由于**进程是相互隔离**的，因此当一个页面或者插件崩溃时，影响到的仅仅是**当前的页面进程或插件进程**，并不会影响到浏览器和其他页面。

#### 解决不流畅的问题：

**JavaScript 运行在渲染进程**中，因此即使 JavaScript 阻塞了渲染进程，影响到的也只是**当前的渲染页面**，并不会影响浏览器和其他页面。

- 其他页面的脚本运行在它们自己的渲染进程之中。
- 在 Chrome 中运行死循环脚本，仅当前的页面会失去响应，不会影响其他的页面以及浏览器的其他模块。

#### 解决内存泄漏的问题：

因为关闭一个页面时，**整个渲染进程都会被关闭**，该进程所占有的内存将会被系统回收。

轻松解决了浏览器页面的内存渲染问题。

#### 解决不安全的问题：

使用多进程架构的额外好处是可以使用 **安全沙箱**：

- 可以看作是操作系统给进程上了一把锁。
- 沙箱里面的程序可以运行，但不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。

Chrome 的插件进程和渲染进程都位于沙箱中，即使在渲染进程和插件进程中执行了恶意程序，也无法突破沙箱去获取系统权限。



### Chrome 最新的进程架构

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a0e8b5d3ce19tplv-t2oaga2asx-zoom-in-crop-mark4536000-16658376864493.awebp)

**最新的 Chrome 浏览器包括：**

- 1 个浏览器主线程
- 1 个 GPU 进程
- 1 个网络（Network）进程
- 多个渲染进程
- 多个插件进程

#### 浏览器进程

- 主要负责界面显示、用户交互、子进程管理。
- 同时提供存储等功能。

#### 渲染进程

- 核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

- 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。

- 默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。

  > 这里记得好像，同源的页面会使用同一个进程

- 出于安全考虑，渲染进程都是运行在该沙箱模式下的。

#### GPU 进程

- GPU 的使用初衷是为了实现 3D CSS 的效果
- 随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，使得 GPU 成为浏览器普遍的需求。
- 因此，Chrome 在其多进程架构上引入了 GPU 进程。

#### 网络进程

- 主要负责页面的网络资源加载。
- 之前作为一个模块运行在浏览器进程之中，现在独立出来成为一个单独的进程。

#### 插件进程

- 主要负责插件的运行。
- 因为插件容易崩溃，因此需要通过插件进程来隔离，保证不会对浏览器和页面造成影响。

### 多进程架构的问题

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但也带来了一些问题：

- **更高的资源占用**：因为每个进程都会包含公共基础结构的副本（如 JavaScript 的运行环境），导致浏览器会消耗更多的内存资源。
- **更复杂的体系结构**：浏览器各模块之间耦合性高，扩展性差等问题，导致现在的架构很难适应新的需求。

### 未来面向服务的架构

面向服务的架构（Services Oriented Architecture，简称 SOA）：

Chrome 将 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统的底层服务。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a0745f8b3616tplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

#### 📌 为什么单进程浏览器不可以采用安全沙箱？

- 如果进程使用了安全沙箱后，该进程对于操作系统的权限就会受到限制。
  - 比如不能对一些位置的文件进行读写操作。
  - 而浏览器主进程需要这些权限，用于缓存数据，cookie，保存浏览记录，文件下载。

#### 📌 打开 Chrome 浏览器的一个 Tab 页面，至少会出现几个进程？

**至少会有 4 个进程：**

- 1 个浏览器主线程
- 1 个 GPU 进程
- 1 个网络（Network）进程
- 渲染进程

一些复杂的情况：

- 页面中有 `iframe` 的话，`iframe` 会单独在进程中。
- 有插件的话，**插件** 也会开启进程。
- 多个页面属于同一站点，且一个页面是通过同站点的另一个页面打开时，会共用一个渲染进程。
- 安装了扩展，扩展也会占用进程。

### 📌即使是如今的多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？

- Chrome 的默认策略是，每个 Tab 标签对应一个渲染进程。
- 但如果从一个页面打开了新页面，并且新页面与当前页面属于同一站点，新页面会复用父页面的渲染进程。（该默认策略称为 `process-per-site-instance`）
  - ！
- 在这种情况下，如果一个页面崩溃了，会导致同一站点的其他页面也崩溃，因为它们共用一个渲染进程。

## HTTP 请求

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a0797ee78e56tplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

**浏览器中的 HTTP 请求一共经历如下八个阶段：**

1. 构建请求
2. 查找缓存
3. 准备 IP 和端口
4. 等待 TCP 队列
5. 建立 TCP 连接
6. 发起 HTTP 请求
7. 服务器处理请求
8. 服务器返回请求和断开连接

#### 1. 构建请求

浏览器构建请求行信息，构建好后，准备发起网络请求：

```HTTP
GET /index.html HTTP/1.1
```

#### 2. 查找缓存

**浏览器缓存：在本地保存资源副本，以供下次请求时直接使用的技术**。

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。

当浏览器发现请求的资源已经在浏览器缓存中存有副本：

- 它会**拦截请求**，**返回该资源的副本**，并直接**结束请求**。而不会再去源服务器重新下载。
- 这样做的好处：
  - **缓解服务器端压力，提升性能**（获取资源的耗时更短了）
  - 对于网站来说，缓存是实现**快速资源加载**的重要组成部分。

如果缓存查找失败，就会进入网络请求过程。

#### 3. 准备 IP 地址和端口

HTTP 和 TCP 的关系：

- 浏览器使用 HTTP 协议作为应用层协议，用于封装请求的文本信息。
- 并使用 TCP/IP 作为传输层协议将其传送到网络上。
- 因此在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。而建立 TCP 连接第一步需要准备 IP 和端口号。

![TCP 和 HTTP 的关系示意图](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a07e9de33cc8tplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

通过 DNS 获取域名对应的 IP，DNS 是用于将域名映射为 IP 的一套系统，称为 域名系统，简称 DNS。

浏览器会通过请求 DNS 服务器返回域名对应的 IP。

并且浏览器提供了 **DNS 缓存服务**。

- 如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用。
- 这样可以减少一次网络请求。

如果 URL 没有指明端口号，那么 HTTP 协议默认为 80 端口。

#### 4. 等到 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接。

如果在同一个域名下有多于该限制的请求发生，那么新的请求将会进入排队等待状态，直至进行中的请求完成。

如果当前的请求数量小于 6，会直接开始建立 TCP 连接。

##### 📌 如果有很多图片资源或其他资源请求怎么办？

#### 5. 建立 TCP 连接

TCP 是面向连接的，可靠的，基于字节流的传输层协议。

一个完整的 TCP 连接生命周期包括了 **建立连接**，**传输数据**，**断开连接** 三个阶段。

#### 6. 发送 HTTP 请求

![HTTP请求数据格式](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a08c0a1dc8f3tplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

- **请求行**： 请求方法，请求 URL ，HTTP 协议版本。
- **请求头**： 将浏览器的基础信息告诉服务器，如客户端所使用的操作系统，浏览器的内核信息，以及请求的域名信息，浏览器的 cookie 信息……

### 7. 服务器端处理 HTTP 请求流程

##### 返回请求

- **响应行**： HTTP 协议版本 状态码 状态字符串。
- **响应头**：服务器的信息，如服务器生成数据的时间，返回数据的类型，以及服务器在客户端保存的 cookie 等信息。

![服务器响应的数据格式](E:\js\java-script-learning-notes\浏览器渲染.assets\1731a091ba9262f5tplv-t2oaga2asx-zoom-in-crop-mark4536000.awebp)

### 8. 断开连接

一般情况下，服务器发送完数据后，就要关闭 TCP 连接。

除了 `Connection:Keep-Alive`

如果在服务器 / 浏览器的头信息中加入上面的字段， TCP 连接仍然会保持，浏览器就可以通过同一个 TCP 连接发送请求。

- 保存 TCP 连接可以省去下次请求需要建立连接的时间，提升资源加载速度。

## 渲染流程

- 渲染引擎：Rendering Engine，或称浏览器内核。
- 渲染引擎主要包括的线程：
  - GUI 渲染线程
  - JavaScript 引擎线程
  - 事件触发线程
  - 定时触发器线程
  - HTTP 异步请求线程

### 各个浏览器线程主要职责

- **GUI 渲染线程**： GUI 渲染线程负责**渲染浏览器界面**。
  - 解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
  - 当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。
- **JavaScript 引擎线程**：JavaScript 引擎线程主要负责**解析 JavaScript 脚本并运行相关代码**。
  - 在一个 Tab 页中（即一个  Renderer 渲染进程中），只有一个 JavaScript 线程。
  - GUI 线程与 JavaScript 线程是互斥的。因此当 JavaScript 操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞。
- **事件触发线程**：当一个事件被触发时，该线程会把事件添加到 JavaScript 引擎的宏任务队列的队尾，等待 JavaScript 引擎的处理。
  - 这些事件可以是当前执行的代码块，如定时任务。
  - 也可以来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等。
- **定时器触发器线程**：负责 setInterval 和 setTimeout 的计时。
  - 由于 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确，因此需要通过一个单独的线程来计时。
- **HTTP 异步请求线程**：在 XMLHttpRequest 连接后，会通过浏览器新开一个线程请求，即 HTTP 请求线程。
  - 它会检测状态变更，如果有设置回调函数，异步线程就产生状态变更事件，并放入 JavaScript 引擎的宏任务队列中等待处理。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ebe6c3160d94tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

### 渲染机制

总结为以下阶段：

1. 构建 DOM 树
2. 样式计算
3. 布局阶段
4. 分层
5. 绘制
6. 分块
7. 光栅化
8. 合成

渲染引擎从网络进程拿到字节流数据后，经过了这些子阶段的处理，最后输出像素。

#### 1. 构建 DOM 树

将 HTML 内容转换为浏览器 DOM 树结构：

- 字节 → 字符 → Tokens → 节点 Nodes → 对象模型（DOM）

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ebfbe591dab1tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

1. **转换：** 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（如 UTF-8）将它们转换成各个字符。
2. **令牌化 Tokenizer：** 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌。
   - 每个令牌都具有特殊含义和一组规则。
3. **词法分析：** 发出的令牌转换成定义其属性和规则的**对象**。
4. **DOM 构建：** 最后，由于 HTML 标记定义不同标记之间的关系，创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：html 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。

#### 2. 样式计算

主要有三个步骤：

1. **格式化样式表**

   - 渲染引擎收到 CSS 文本数据后，会执行一个操作，将文本数据转换为浏览器可以理解的结构 `styleSheets`。
   - 通过浏览器控制台的 `document.styleSheets` 可以查看这个最终结果。

2. **标准化样式表**

   - `em` → `px`

   - `red` → `rgba(255,0,0,0)`

   - `bold` → `700`

     ![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec053f5d9188tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

3. **计算每个 DOM 节点具体样式**

   - 计算规则：**继承** & **层叠**
     - 继承：每个子结点会默认去继承父节点的样式，如果在父节点中找不到，会采用浏览器默认的样式，即 `UserAgent` 样式。
     - 层叠：样式层叠，是 CSS 的一个基本特征，它是定义如何**合并来自多个源的属性值**的算法。
   - 计算完样式后，所有的样式值都会被挂到 `window.getComputedStyle` 当中，即可以**通过 JavaScript 来获取计算后的样式**。

#### 3. 布局

1. **生成布局树：**
   - 通过浏览器的布局系统确定元素位置，即生成一棵**布局树（Layout Tree）**。
2. **创建布局树：**
   - 在 DOM 树上不可见的元素，最后都不会出现在布局树上。
     - 如 `head`、`meta` ，以及使用 `display:none` 属性的元素
   - 所以浏览器布局系统需要额外去**构建一棵只包含可见元素的布局树**。![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec0e12a95ce8tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)
3. **布局计算**
   - 

#### 4. 分层

- 生成图层树（Layer Tree）
- 拥有层叠上下文属性的元素会被提升为单独一层
- 需要裁剪（clip）的地方也会创建图层
- 图层绘制

浏览器构建完布局树后，还需要进行一系列的操作，是因为考虑到了一些复杂的场景：

- 复杂的 3D 变换
- 页面滚动
- z-index 做 z 轴排序
- 层叠上下文控制显示和隐藏的情况

##### 生成图层树

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

渲染引擎为特定节点创建新图层：

###### 显式合成

1. 拥有层叠上下文的节点。
   - 层叠上下文基本上是由一些特定的 CSS 属性创建的：
     - HTML 根元素本身就具有层叠上下文
     - 普通元素设置 `position` 不为 `static`，并且设置了 `z-index` 属性，会产生层叠上下文。
     - 元素的 `opacity` 值不为 1
     - 元素的 `transform` 值不是 `none`
     - 元素的 `filter` 值不是 `none`
     - 元素的 `isolation` 值为 `isolate`
     - `will-change` 指定的属性值为上面的任意一个。
2. 需要剪裁（clip）的地方
   - 比如一个元素里面放了非常多的文字，超出了元素的大小，那么超出的文字部分就需要被剪裁。
   - 如果出现了滚动条，那么 **滚动条也会被单独提升为一个图层**。

元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升为单独一层。

###### 隐式合成

`z-index` 比较低的结点会提升为一个单独的图层，层叠等级比它高的结点都会成为一个**独立的图层**。

缺点：

- 在大型项目中，一个 `z-index` 比较低的节点被提升为单独的图层后，层叠在它上面的元素统统都会提升为单独的图层。
- 如果有上千个图层，就会增大内存的压力，有时候会让页面崩溃，即**层爆炸**。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec227a0226f4tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

#### 5. 绘制

会将每个图层拆分为很小的 **绘制指令**，然后再按照这些指令的顺序组成一个 **绘制列表**。

- 绘制列表的指令都非常简单，就是执行一个简单的绘制操作。
- 绘制一个元素通常需要好几条绘制指令，因为每个元素的背景，前景，边框都需要单独的指令去绘制。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec5057d218c2tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

#### 6. 分块

绘制操作由渲染进程中专门的线程完成，这个线程叫做**合成线程**。

绘制列表准备好了之后，渲染进程的主线程会给 合成线程 发送 `commit` 消息，把 **绘制列表** 提交给合成线程。

合成线程会将图层划分为 **图块 tile**。

- 有时候，页面比较长，图层比较大，用户只能看到页面的很小一部分，要绘制出所有图层内容的话，就会产生较大的开销，也没有必要。
- 图块的大小一般为 256 * 256 或 512 * 512 这个规格，这样可以大大加速页面的首屏展示。

##### 首屏渲染加速

因为后续非视口内的图块数据要进入 GPU 内存，考虑到**浏览器内存**上传到 **GPU 内存** 的操作比较慢，即使是绘制一部分图块，也可能耗费大量时间。

针对这个问题， Chrome 采用了一个策略：==**在首次合成图块时只采用了一个低分辨率的图片。**==

这样首屏展示的时候只是展示出低分辨率的图片，这个时候**继续进行合成操作**，**当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换**。

#### 7. 光栅化

有了图块之后，合成线程会按照 **视口附近的图块优先** 来生成**位图**，实际生成位图的操作是由 **栅格化** 来执行的。

**栅格化：** 将图块转换为位图。

- **图块**是栅格化执行的最小单位。
- 渲染进程中专门维护了一个 **栅格化线程池**，专门负责把图块转换为位图数据。
- 合成线程会选择视口附近的 **图块（tile）**，把它交给栅格化线程池生成位图。
- 生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给 **合成线程**。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec2b64158acctplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫**快速栅格化**，或者 **GPU 栅格化**，生成的位图被保存在 **GPU 内存**中。

GPU 操作运行在 GPU 进程中，如果栅格化操作使用了 GPU，那就涉及到了跨进程操作。

![img](E:\js\java-script-learning-notes\浏览器渲染.assets\1732ec2dd96a2e48tplv-t2oaga2asx-zoom-in-crop-mark4536000.image)

#### 8. 合成和显示

栅格化操作完成后，**合成线程** 会生成一个绘制命令，即 **DrawQuad**，并发送给浏览器进程。

**浏览器进程** 中的 `viz` 组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。

> 无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将`前缓冲区`和`后缓冲区`对换位置，如此循环更新。

因此当某个动画大量占用内存时，浏览器生成图像会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。



## 图层

一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。

不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。

但也不能生成过多的图层，会引起反作用。

通过以下几个常用属性可以生成新图层：

- 3D 变换：`translate3d`、`translateZ`
- `will-change`
- `video`、`iframe` 标签
- 通过动画实现的 `opacity` 动画转换
- `position:fixed`

### 重绘（Repaint）和回流（Reflow）

重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。

- 重绘是指当前节点需要改变外观但不会影响布局，比如改变 `color` 或 `opacity`。
- 回流是指布局或者几何属性需要改变。

回流必然会发生重绘，但重绘不一定会引发回流。

回流所需的成本与重绘高很多，改变深层次的结点很可能导致父结点的一系列回流。

下列动作可能会导致性能问题：

- 改变 window 大小
- 改变字体
- 添加或删除样式
- 文字改变
- 定位或者浮动
- 盒模型

重绘和回流与 Event loop 有关：

1. 当 Event loop 执行完 Microtasks 后，如果到了浏览器的刷新周期，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。
2. 判断是否发生 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 `media query`
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimaationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上
8. 更新界面
9. 以上为一帧中可能会做的事情。如果在一帧中还有空闲时间，就会去执行 `requestIdleCallback` 回调。

### 减少重绘和回流

- 使用 `translate` 替代 `top / bottom / left / right`定位。
- 使用 `visibility` 替代 `display: none`。
- 把 DOM 离线后修改，如先为 DOM 设置 `display: none`，然后修改多次后再显示出来。
- 避免多次读取 `offsetWidth` 类似会引起一次重绘的值。
- 不要使用 table 布局，很小的改动会造成整个 table 重新布局。
- 动画实现可以选择 `requestAnimationFrame`，或独立为一个单独的图层，图层能够阻止该节点回流影响别的元素。
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深。

