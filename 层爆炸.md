## 浏览器渲染的流程：

1. 构建 DOM 树
2. 样式计算
3. 布局定位
4. 图层分层
5. 图层绘制
6. 合成显示

当 CSS 属性改变时，重渲染会分为 **回流**、**重绘** 和 **直接合成** 三种情况，分别对应从 **布局定位**、**图层绘制**、**合成显示** 开始，再次走一遍浏览器渲染的流程。

根据元素的 CSS 具体发生的改变，决定属于上面哪种情况：

- 重绘：修改了一些不影响布局的属性，比如颜色。

  - 没有改变元素几何信息，直接跳过布局阶段。
  - 触发 paint 以及后面整个流程的更新。

  ![chonghui.webp](E:\js\java-script-learning-notes\层爆炸.assets\be94b6ad26c5439cb1a3b0ca24f3dcfdtplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp)

- 回流（重排）：元素位置、大小发生变化导致其他节点联动，需要重新计算布局：

  ![chongpai.webp](E:\js\java-script-learning-notes\层爆炸.assets\54479d99450640ee92b830d56f16811ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp)

- 直接合成：合成层的 `transform`、`opacity` 修改，只需要将多个图层再次合并，然后生成位图，最终展示到屏幕上。

  - 直接跳过布局和绘制阶段。
  - 触发 paint 后面整个流程的更新。

  ![hecheng.webp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f41e520daf654c3090be9ec7c8da7c56~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 渲染中的层

渲染过程中会发生图层分层。

浏览器中的层分为两种：

- 渲染层
- 合成层（复合层）
  - 在开发者工具中能够看到的为合成层。



## 层叠上下文

**层叠上下文** 是对 HTML 元素的一个三维构想，HTML 元素沿着一条相对于用户的虚构的 z 轴排开。

在 CSS 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴、Y 轴以及表示层叠的 Z 轴。

层叠上下文是 HTML 中某些元素的一个特殊属性，这个属性决定了他在空间的上下位置，而这个位置会影响他们的渲染顺序。

最大的层叠上下文由文档根元素，html 形成：

- 它自身连同它的子元素就形成了一个最大的层叠上下文。
- 我们写的所有代码都是在根层叠上下文里。

特性：

- 层叠上下文可以包含在其他层叠上下文中，并一起创建一个层叠上下文的层级。
  - 每个有 `z-index` 数值的元素会连同它的子元素一起，生成一个小的层叠上下文
  - 这个小的层叠上下文和父级一样，拥有多个平面。
- 每个层叠上下文都是**自包含的**：
  - 当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。

只有明确指定了 `z-index` 的值（非 `auto`） 的定位元素，定义了 `position` 且值非 `static` 才会产生一个层叠上下文，在这个层叠上下文中，内部元素的层级都在它之上，哪怕是负数。



- `z-index` 大的元素一定会盖在小的元素上面吗？
  - 不是，是由于层叠上下文特性，每个层叠上下文是自包含的，元素的位置受他的父级上下文影响。
  - 如果元素的父级上下文层叠等级低，即使给元素的 `z-index` 很高也无法盖过其他父级上下文层叠等级高的元素。
- 给元素设置 `z-index` 为负值，它的层级会被父级覆盖吗？
  - 父级可以盖住子级元素，因为块级元素的层叠等级是高于定位并且 `z-index < 0` 的元素的。

### 层叠等级（规则）：

- 在**同一个层叠上下文**中，它描述定义的是**该层叠上下文中**的层叠上下文元素在 Z 轴上的相对顺序。
- 在其他普通元素中，他描述定义的是这些普通元素在 Z 轴上的相对顺序。

![image.png](E:\js\java-script-learning-notes\层爆炸.assets\81978fcc72f3486a81f9d6a5b9d2b936tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp)

## 渲染层

渲染层的概念与 层级上下文 密切相关。

简单来说，**拥有 `z-index` 属性的定位元素**会生成一个层叠上下文，一个生成层叠上下文的元素就生成了一个渲染层。

在开发者工具中看不到渲染层。

形成渲染层的条件（也即形成层叠上下文的条件）：

1. `document` 元素
2. 拥有 `z-index` 属性的定位元素（`position: relative | fixed | sticky | absolute`）
3. 弹性布局的子项（父元素 `display: flex | inline-flex`），并且 `z-index` 不是 `auto` 时。
4. `opacity` 非 1 的元素
5. `transform` 非 `none` 的元素
6. `filter` 非 `none` 的元素
7. `will-change = opacity | transform | filter`
8. 需要裁剪的元素也会形成一个渲染层，即 `overflow` 不为 `visible` 的元素。

## 合成层

一个合成层中可以包含多个渲染层。

只有一些特殊的渲染层才会被提升为合成层，通常来说有这些情况：

### 显式合成

1. `document` 根元素
2. `transform:3D` 变换：`translate3d`，`translateZ`
3. `will-change: opacity | transform | filter`
4. 对 `opacity |transform | filter` 应用了过渡和动画（`transition / animation`）
5. `video`、`canvas`、`iframe`
6. 可滚动溢出元素，`scrollable`、`overflow`

### 隐式合成

当出现一个合成层后，**层级顺序**高于它的堆叠元素就会发生隐式合成。

隐式合成出现的根本原因：元素发生了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有的合成层上面。

## 层爆炸和层压缩

当页面内容非常多，层级复杂的时候，低层级的渲染层在某一时刻提升为合成层，那么此时就产生了很多预期外的合成层。

- 页面中所有 `z-index` 高于它的节点全部被提升

这些合成层都是相当消耗内存和 GPU 的，这个现象就是层爆炸。

**层爆炸：大量元素意料之外发生了隐式合成，被提升成合成层。**

### 解决思路：

1. **代码层面控制**，在会形成合成层的元素增加一个**大的 `z-index` 属性**，人为干扰合成的排序，可以有效减少不必要的合成层创建，提升渲染性能，移动端优化效果尤为明显。
2. 部分浏览器**层压缩机制**，多个渲染层在同一个合成层重叠时，会自动地将它们压缩到一起，避免层爆炸带来的损耗。
   - 浏览器自动的层压缩也不是万能的，有很多特定的情况下，无法进行层压缩
     - 如设置 `mask` 属性
     - `video` 元素
   - 和具体的浏览器也有关

## 硬件加速

浏览器为什么要进行分层？答案是硬件加速。

硬件加速：使用特定的 CSS 属性，把元素提升至合成层，交给 GPU 处理。

- 合成层会交给 GPU 去处理。
- 提升成合成层的元素如果发生回流 / 重绘，都只影响这一层，将需要重排/重绘的元素单独拎出来，可以减少绘制的面积，渲染效率得到提升。

宽度变化在页面绘制的过程中会不断地重排，还有一种方式是直接合成，如果将变化的属性改为 `transform:scale(2)`，会发现该合成层只绘制了一次。

开启硬件加速后的合成层会交给 GPU 处理。当图层过多时，将会占用大量内存，由其在移动端会造成卡顿，让优化适得其反。

## 优化渲染性能

除了硬件加速之外，提升渲染性能还有这几个常见的方法：

1. 避免重排 / 重绘，直接进行合成，合成层的 `transform` 和 `opacity` 的修改都是可以直接进入**合成阶段**的。
   - 比如使用 `transform: translate` 代替 `left / top` 修改元素的位置
   - 使用 `transform:scale` 代替宽度、高度的修改
2. 注意隐式合成，给合成层一个较大的 `z-index` 值。
   - 虽然大部分浏览器实现了层压缩的能力，但是依旧有无法处理的情况，最好是一开始就避免层爆炸。
3. 减小合成层占用的内存。
   - 合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的。
   - 如果要实现一个 100 * 100 的元素，可以将宽高设置为 10px，再使用 `transform:scale(10)` 放大 10 倍，这样占用的内存只有直接设置的 `1/100`



