## 1.1 编译原理

作用域：**存储变量** 且在 需要时能够**方便地找到目标变量**的一套规则。

​				负责收集并维护所有声明的标识符组成的一系列查询。

​				管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行**变量查找**。

> 尽管通常将JavaScript 归类为【动态】或【解释执行】的语言，但

JavaScript 是一门编译语言。

- 但不是提前编译的
- 编译结果不能在分布式系统中移植

传统编译语言 进行 编译 的三个步骤：

1. **分词/词法分析 Tokenizing/Lexing**

   - 将字符串分解成有意义的代码块，称为词法单元（token）。

   - 分词与词法分析的区别：取决于对词法单元的识别是通过**有状态**还是**无状态**的方式进行的。有状态的是词法分析。

     - > **词法单元生成器** 判断 a 是一个 独立的词法单元 还是 其他词法单元一部分 时，调用的是有状态的解析规则，那么这个过程被称为**词法分析**

2. **解析/语法分析**

   - 将词法单元流转换为**抽象语法树**（AST)

3. **代码生成**

   - 将 AST 转换为可执行代码（一组机器指令）

JavaScript 引擎的编译过程更加复杂。在语法分析和代码生成阶段有特定的步骤对运行性能进行优化。

JavaScript 的编译过程发生在**代码执行前**的几微秒时间内。因此不会有大量的时间用于优化。



## 1.2 理解作用域

变量的赋值操作（如 var a = 2）会执行两个操作。

首先，**编译器**会在当前作用域中声明一个变量（如果之前没有声明过）。

然后，**运行时引擎**会在作用域中查找该变量，如果找到就会对其赋值。



引擎执行的查找类型会影响最终的查找结果。

查找类型有 **LHS** 和 **RHS**。

当变量出现在赋值操作的左侧时，进行 LHS 查询。

- 该查找试图找到**变量的容器**本身，从而可以对其**赋值**。
- 函数参数传递会进行 LHS 查询。

当变量出现在赋值操作右侧（非左侧）时，进行 RHS 查询。

- 是简单地查找**某个变量的值**。

编译器可以在代码生成的同时处理**声明**和**值的定义**。将函数声明理解为LHS查询和赋值的形式并不合适。



## 1.3 作用域嵌套

一个块/函数 嵌套在另一个 块/函数 中，就发生了作用域的嵌套。

**遍历嵌套作用域链**：在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。



## 1.4 异常

### ReferenceError

**==ReferenceError 与作用域判别失败相关。==**

在**变量还没有声明**的情况下，两种查询的行为是不一样的。

 **RHS 查询**在所有嵌套的作用域中遍寻不到所需的变量：

- 引擎就会抛出 **ReferenceError** 异常。

 **LHS 查询**在所有嵌套的作用域中遍寻不到所需的变量：

- 程序在非严格模式下，就会在 **全局作用域** 中创建一个该名称的变量，并将其返还给引擎。
- 程序在严格模式下，**禁止自动或隐式地创建全局变量**。因此引擎会抛出 **ReferenceError**。



### TypeError

==**TypeError 代表作用于判别成功了，但是对结果的操作是非法的。**==

RHS 查询找到一个变量，但是尝试对这个变量进行不合理地操作时：

- 试图对一个非函数类型的值进行函数调用
- 引用 null 或 undefined 类型的值中的属性

引擎会抛出 **TypeError**。



# 二、词法作用域

## 2.1 词法阶段

作用域有两种主要的工作模型：

1. 词法作用域（JavaScript 采取这一种）
2. 动态作用域

词法作用域就是==**定义在词法阶段的作用域。**==

- 作用域是由写代码时将**变量**和**块作用域**声明的位置决定的
- 存在一些欺骗词法作用域的方法，在词法分析器处理过后依然可以修改作用域。

### **遮蔽效应**

作用域查找始终从运行时所处的最内部作用域开始，逐级向外，会在找到第一个匹配的标识符时停止。

- 由 var 声明的全局变量会自动成为 全局对象（window）的属性，因此可以通过**全局对象属性的引用**来访问被遮蔽的全局变量。

### 词法作用域查找只会查找一级标识符

a.b.c 词法作用域只会试图查找 a 标识符，找到这个变量后，

对象属性访问规则会分别接管对 b 和 c 属性的访问。

## 2.2 欺骗词法

欺骗词法作用域会导致性能下降。

### eval

`eval() `接受一个字符串作为参数，并将其中的内容视为书写时就位于该位置的代码。

如果`eval(…) `中执行的代码包含有声明（变量或函数），**就会在运行期间对 `eval(…)` 所处的词法作用域进行修改。**

在严格模式的程序中，` eval() `在运行时**有其自己的词法作用域**。其中的声明无法修改所在的作用域。

还有一些其他函数与 `eval()` 很相似：

- `setTimeout()` 第一个参数可以为字符串，将被解释为一段动态生成的函数代码。
- `new Function()` 最后一个参数可以接受代码字符串，并将其转化为动态生成的函数，前面的参数将作为动态生成的函数的形参。

==严格模式下，间接或非安全地使用`eval() `被禁止。==

### with

`with `将一个对象的引用作为**完全隔离的词法作用域**，将**对象的属性**当作作用域中的**标识符**来处理。

创建的新作用域嵌套在` with `语句处。

- 块内部的` var `声明并不会被限制在这个块的作用域中，而是被添加到 `with `所处的函数作用域中。
- `with `通常被当作**重复引用 同一个对象中的多个属性 的快捷方式**，可以无需重复引用对象本身。
- 在块作用域中未找到所需的标识符时，会进行正常的 作用域查找。

==严格模式下` with `被完全禁止。==



## 2.3 性能

JavaScript 引擎会在编译阶段进行数项的性能优化，

其中有些优化依赖于**对代码词法的静态分析，以及预先确定所有变量和函数的定义位置**。

才能在执行过程中快速找到标识符。

如果代码中大量使用 eval() 或 with，引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的，将会导致代码运行变慢。 



# 三、函数作用域和块作用域

## 3.1 函数的作用域

JavaScript 具有基于函数的作用域。

**函数作用域**：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也可以）。

无法从函数作用域的外部访问其中的变量，会导致 ReferenceError 错误。

## 3.2 隐藏内部实现

**最小特权原则（最小授权/暴露原则）**：指在软件设计中应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

### 规避冲突

1. 全局命名空间
   - 程序加载了多个第三方库，通常会在全局作用域中声明一个特别的变量，常为一个对象，被用作库的**命名空间**。
   - 所有需要暴露的功能会成为这个对象的属性。
2. 模块管理
   - 使用模块管理器，将库的标识符显式地导入另一个特定的作用域中。而不需加入全局作用域中。

## 3.3 函数作用域

通过包装函数可以将内部的变量和函数定义隐藏起来，

但声明一个具名函数，

- 函数名称污染了所在的作用域。
- 且必须显式地通过函数名调用才能运行其中的代码。

函数无需函数名，且能够自动运行的方案：IIFE。



**函数声明**与**函数表达式**之间最重要的区别为 <u>它们的名称标识符会被绑定在何处</u>：

- 函数声明 的名称被绑定在**所在的作用域中**。
- 函数表达式 的名称被绑定在**表达式自身的函数**中。

区分**函数声明**与**函数表达式**的方式：

- 如果function是声明中的第一个词，为函数声明。否则为函数表达式。



### 匿名函数表达式

函数声明必须为具名的，函数表达式可以是匿名的。

缺点：

- 匿名函数在栈追踪中不会显示出有意义的函数名，调试较困难。
- 在函数中不能引用自身。
  - 递归，解绑事件监听器 等情况，只能使用不被推荐的 arguments.callee。
- 降低了代码可读性。

行内函数表达式可以有效解决。

### 立即执行的函数表达式

```js
(function(){..})()
(function(){..}())
```

可以倒置代码的运行顺序，在UMD项目中广泛使用。

```js
(function IIFE(def){
	def(window)
})(function def(global){
	console.log(global.a)
})
```

## 3.4 块作用域

### with

with 从对象中创建出的作用域仅在 with 声明中而非外部作用域有效。

### try/catch

ES3 规范中规定的 try / catch 的 **catch 分句** 会创建一个块作用域。

- 但当同一作用域中的 两个或多个 catch 分句 用同样的标识符名称声明错误变量时，静态检查工具还是会发出警告。 

### let

let 为其声明的变量隐式地劫持了所在的块作用域。

let 声明不会在块作用域中进行提升。声明的代码在被运行前，并不存在。



块作用域的使用:

#### 垃圾收集

显式声明的块作用域，在 代码运行之后 块中使用 let 定义的内容可以立刻被销毁。不受 覆盖函数作用域的闭包 的影响。

#### let 循环

for 循环头部的 let 将变量绑定到了**循环的每一次迭代**中，使用<u>上一个循环迭代结束时的值</u>重新进行赋值。



### const

用于创建块作用域变量，但其值是固定的。

# 四、提升

引擎在**编译阶段**会找到所有的声明，并用合适的作用域将它们关联起来。

变量和函数在内的**所有声明**都<u>会在任何代码被执行</u>前**首先被处理**。

可以形象地当作所有的声明被移动到各自作用域的顶部，即**声明会被提升**，

而包括函数表达式的赋值在内地赋值操作不会被提升。

- 函数表达式（即使是具名的），名称标识符在赋值之前也无法在所在作用域中使用。

**每个作用域都会进行提升操作。**



- **函数**先于变量被提升。
- 块作用域中的函数声明会被提升至所在函数作用域的顶部。
- var 变量声明 与 函数声明 重复时，变量声明会被忽略。
- 重复的函数声明，后面的会覆盖前面的。

# 五、作用域闭包

**闭包：函数能够记住并访问所在的词法作用域**。即使函数是在被定义的词法作用域之外执行。

**将 ==内部函数== 值传递至 所在词法作用域之外，内部函数仍然持有对 ==定义作用域 的引用==，无论何时执行这个函数都会使用闭包。**

词法作用域的查找规则为闭包的一部分。

在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workers 或者任何其他的异步（或者同步）的任务中，只要

**使用回调函数，实际上就是在使用闭包**。

- IIFE 严格来讲并不是闭包，因为函数并不是在它本身的词法作用域以外执行的。变量是通过普通的词法作用域查找而非闭包被发现的。

## 5.1 循环与闭包

```js
for(var i = 1; i <= 5; i++) {
	setTimeout( function timer(){
		console.log(i);
	}, i * 1000 );
}
```

多个 timer 函数都被封闭在一个共享的全局作用域中，共享一个 i 的引用。

要想实现预期效果，我们在循环过程的每一个迭代中都需要一个**闭包作用域**，并在作用域中保存迭代变量的值。

```js
for(var i = 1; i <= 5; i++) {
	(function (j){
    setTimeout( function timer(){
			console.log(i);
		}, i * 1000 );
  })(i)
}
```

换句话说，每次迭代我们都需要一个**块作用域**。

本质上，这是将一个块转换成一个可以被关闭的作用域。

```js
for(var i = 1; i <= 5; i++) {
  let j = i;
	setTimeout( function timer(){
		console.log(j);
	}, j * 1000 );
}
// or

for(let i = 1; i <= 5; i++) {
	setTimeout( function timer(){
		console.log(i);
	}, i * 1000 );
}
```

for 循环头部的 let 会在每次迭代声明一个独立的迭代变量，并使用上一次迭代结束时的值来初始化这个变量。

## 5.2 模块

```js
function CoolModule(){
	var something = "cool"
	var another = [1, 2, 3]
	
	function doSomething(){}
	function doAnother(){}
	
	return {
		doSomething,
		doAnother
	}
}

var foo = CoolModule()
foo.doSomething()
foo.doAnother()
```

这个模式在 JavaScript 中称为模块。

最常见的实现模块模式的方法：**模块暴露**。



### **模块模式的两个必要条件**：

1. **为创建内部作用域而调用了一个包装函数。**（每次调用都会创建一个新的模块实例。）
2. **包装函数的返回值必须至少包括一个对内部函数的引用**，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。
   - 保持内部数据变量是隐藏且私有的状态。
   - 函数具有涵盖包装函数内部作用域的闭包。

### **单例模式**

可通过将模块函数转换为 IIFE 实现。

```js
var foo = (function CoolModule(){
	var something = "cool"
	var another = [1, 2, 3]
	
	function doSomething(){}
	function doAnother(){}
	
	return {
		doSomething,
		doAnother
	}
})();
```

### **现代的模块机制**

```js
let MyModules = (function Manage(){
	let modules = {};
	
	function define(name, deps, impl){
		for(let i = 0; i < deps.length; i++){
			deps[i] = modules[deps[i]]
    }
    modules[name] = impl.apply(impl, deps)
    // 将模块的 API，储存在一个根据名字来管理的模块列表中。
	}
	
	function get(name) {
		return modules[name]
	}
	
	return {
		define,
		get
	}
})
```

### 未来的模块机制

ES6 为模块增加了一级语法支持。

- 会将文件当作独立的模块来处理。
- 每个模块都可以导入其他模块或特定的 API 成员。
- 也可以导出自己的 API 成员。

ES6 模块与 基于函数的模块的比较：

- 基于函数的模块**不能被静态识别**，可以在运行时修改一个模块的 API。
- 而 ES6 模块 API 是静态的，因而可以在**编译期**检查对<u>导入模块的 API 成员的引用是否真实存在</u>。无需等到运行期再动态解析。

**ES6 的模块没有行内格式，必须定义在独立文件中。**

模块文件中的内容会被当作好像包含在**作用域闭包**中一样来处理。

- `import` 可以将一个模块中的一个或多个API 导入到当前作用域中。
- `module` 会将整个模块的 API 导入并绑定到一个变量上。
- `export` 会将当前模块的一个标识符导出为公共 API 。



# 附录A 动态作用域

动态作用域与 JavaScript 中的 this 机制相似。

动态作用域的作用域链是基于**调用栈**的，而不是代码中的作用域嵌套。

- 词法作用域关注函数在何处声明，动态作用域关注函数从何处调用。



# 附录B 块作用域的替代方案

在 ES6 之前，使用 try/catch 来实现块作用域，生成兼容 ES5 的代码。

IIFE 与 try/catch 并非完全等价的，因为如果将一段代码中的任意一部分用函数进行包裹，会改变这段代码的含义。

**其中的 this、return、break 和 continue都会发生变化**。

因此 IIFE并不是一个普适的解决方案。



# 附录C this 词法

**ES6 中的 箭头函数**是用于函数声明的特殊语法，将 this 同 词法作用域联系起来。

```js
var obj = {
	id:'awesome',
	cool:function coolFn(){
		console.log(this.id);
	}
};

var id = "not awesome"

obj.cool() // awesome
setTimeout(obj.cool,100) // not awesome
//回调函数中 cool 函数丢失了同 this 之间的绑定
```

**①var self = this** 使用了词法作用域进行修复。

```js
var obj = {
	count:0,
	cool:function coolFn(){
		var self = this
		if(self.count < 1){
			setTimeout(function timer(){
				self.count ++;
			})
		}
	}
}
```

**②ES6 的箭头函数引入了一个叫做 this词法 的行为**。

箭头函数涉及 this 绑定时，放弃了所有普通 this 绑定的规则。

而是使用 **当前的词法作用域**覆盖了 this 本来的值。

继承了外部函数的 this 绑定。

```js
var obj = {
	count:0,
	cool:function coolFn(){
		if(this.count < 1){
			setTimeout(() => {
				this.count ++;
			})
		}
	}
}
```

导致箭头函数不够理想的原因是 **它们是匿名的而非具名的**。

**③硬绑定this，正确使用和包含 this 机制**

```js
var obj = {
	count:0,
	cool:function coolFn(){
		if(this.count < 1){
			setTimeout(function timer(){
				this.count ++;
			}.bind(this), 100)
		}
	}
}
```

