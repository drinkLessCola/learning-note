# 三、运输层

运输层的关键功能：

将 **网络层** 的在 **两个端系统** 之间的交付服务 扩展到 运行在两个**不同端系统上的应用层进程**之间的交付服务。

网络中的基础性的重要问题：

1. 两个实体怎样才能在一种会丢失或损坏数据的媒体上可靠的通信。
2. 控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复过来。

## 1.概述和运输层服务

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**功能。

运输层协议是在**端系统**中而不是在路由器中实现的。

- 在发送端，接收应用层的报文并转为报文段。移交到网络边缘。
- 网络路由器仅<u>作用于该数据报的网络层字段</u>，不检查封装在该数据报的运输层报文段字段。
- 在接收端，网络层从数据报中提取运输层报文段，并将该报文段上交给运输层。

 **报文段**：运输层将从 发送应用程序进程 接收到的报文转换为的运输层分组。

- 将应用报文划分为较小的块。
- 为每块加上一个运输层首部。

### 1.1 运输层和网络层的关系

**网络层** 提供了<u>主机</u>之间的逻辑通信。

**运输层** 提供了运行在<u>不同主机的进程</u>之间的逻辑通信。

计算机网络中可以安排多种 运输层协议，每种协议为应用程序提供不同的服务模型。

- **`UDP` 用户数据报协议**：提供不可靠、无连接服务。
- **`TCP` 传输控制协议**：提供可靠的，面向连接的服务。
- 应用程序在生成套接字时指定选择其中一个。

**运输协议提供的服务常常受制于网络层协议的服务模型**。

- 如果网络层协议无法为主机之间发送的运输层报文段提供时延或带宽保证的话，运输层协议也无法为进程之间发送的应用程序报文提供时延或带宽保证。

即使底层网络协议不能在网络层提供相应的服务，**运输层协议也能提供某些服务。**

- 即使底层网络协议是**不可靠**的，会使分组丢失、篡改和冗余。运输协议也能为应用程序提供**可靠**的数据传输服务。
- 即使网络层不能保证运输层报文段的**机密性**，运输协议也能使用**加密**来确保应用程序报文不被入侵者读取。



因特网网络层协议有一个 IP 协议（即网际协议）。

IP 的服务模型是 **尽力而为交付服务**。是一种 **不可靠服务**。

- 不确保报文段的交付。
- 不保证报文段的按序交付。
- 不保证报文段中的数据的完整性。

每台主机至少有一个网络层地址，即 IP 地址。



UDP 和 TCP 最基本的责任，最低限度的运输层服务：

- **进程到进程的数据交付**：将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。
- **差错检查**：还可以通过在其报文段首部中包括差错检查字段而提供完整性检查。

也是 UDP 所能提供的仅有的两种服务。

**运输层的多路复用和多路分解**：主机间交付扩展到进程间交付。



- **UDP 是一种不可靠的服务。 **
  - 不能保证一个进程所发送的数据能够完整无缺地到达目的进程。
- **UDP 流量是不可调节**的，使用 UDP 传输的应用程序可以根据其需要以其愿意的任何速率发送数据。



- **TCP 提供可靠数据传输**：通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。

- 也**提供拥塞控制**。通过调节 TCP 连接发送端发送进网络的流量速率来实现。
  - 防止任何一条 TCP 连接用过多流量来淹没通信主机之间的链路和交换设备。
  - 使通过一条拥塞网络链路的连接平等地共享网络链路带宽。

## 2. 多路复用与多路分解

一个进程有一个或多个**套接字**。**每个套接字都有唯一的标识符。**

在接收主机中运输层实际上是将数据交给了一个套接字。

**多路分解**：将运输层报文段中的数据交付到**正确的套接字**的工作。

- 主机上的每个套接字能够分配一个端口号。
- 当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。

**多路复用**：在源主机**从不同套接字**中收集数据块，并**为每个数据块封装上首部信息，从而生成报文段**，将报文段**传递到网络层**的工作。

**多路复用要求：**

- 套接字有唯一标识符
- 每个报文段有特殊字段来指示该报文段所要交付到的套接字。
  - 这些特殊字符为 **源端口号字段** 和 **目的端口号字段**。
  - 端口号是一个 16 bit 的数，其大小在 0 ~ 65535 之间。
  - **周知端口号**：0 ~ 1023，保留给 HTTP(80)、FTP(21) 等周知应用层协议使用。



### 2.1. 无连接的多路复用与多路分解

通常，应用程序的客户端让运输层自动地（并且是透明地）分配端口号，而服务器端则分配一个特定的端口号。

运输层报文段包括**应用程序数据、源端口号、目的端口号和其他两个值**。

- 源端口号用作“返回地址”的一部分。



一个 **UDP 套接字** 是由一个 **二元组** 全面标识的。

- 包含一个**目的 IP 地址和一个目的端口号**。

如果两个 UDP 报文段有不同的源 IP 地址 / 源端口号，但具有相同的目的 IP 地址和 目的端口号，**那么这两个报文段将通过==相同的套接字==被定向到==相同的目的进程==。**

### 2.2. 面向连接的多路复用与多路分解

**TCP 套接字是由一个四元组来标识的。**

- 源 IP 地址
- 源端口号
- 目的 IP 地址
- 目的端口号

与 UDP 不同，两个具有不同源 IP 地址或源端口号的 TCP 报文段将被定向到两个不同的套接字。

**除非 TCP 报文段携带了初始创建连接的请求。** 

- 一条连接建立请求只不过是一个目的端口号特定， TCP 首部的特定 **“连接建立位” 置位**的 TCP 报文段。

- 服务器进程根据上述 4 个值来标识新创建的连接套接字。
- 所有后续到达的报文段，如果它们的**源端口号，源主机 IP 地址，目的端口号和目的 IP 地址都与这 4 个值匹配**，则被分解到这个套接字。

服务器主机可以支持很多并行的 TCP 套接字。

### 2.3. Web 服务器与 TCP

初始连接建立报文段 和 承载 HTTP 请求 的报文段都有 80 的目的端口。

Web 服务器可以为每条连接生成一个**新进程**。每个进程都有自己的连接套接字。

**连接套接字与进程之间并非总是一一对应。**

当今的高性能 Web 服务器通常只使用一个进程，但是为每个新的客户连接创建一个**具有新连接套接字的新线程**。

- 因此在任意给定时间内都可能有许多连接套接字连接到**相同的进程**。

持续 HTTP 连接：

- 在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换 HTTP 报文。

非持续 HTTP：

- 则对每一对请求 / 响应都创建一个新的 TCP 连接（套接字）并在随后关闭。
- 套接字的频繁创建和关闭会严重地影响一个繁忙的 Web 服务器的性能。

## 3. 无连接运输： UDP

UDP 从应用进程得到数据，附加上用于 **多路复用/分解服务的源和目的端口号字段**，以及**两个其他的小字段**，然后将形成的报文段交给网络层。

UDP 使用目的端口号将报文段中的数据交付给正确的应用进程。



**UDP 是无连接的：**在发送报文段之前，发送方和接收方的运输层实体之间没有握手。

**UDP 没有拥塞控制**：UDP 缺乏拥塞控制能够导致 UDP 发送方与接收方之间的**高丢包率**，并**挤垮 TCP 会话**。

- **高丢包率**：UDP 广泛应用会使路由器中大量分组溢出，以至于非常少 UDP 分组能够成功到达目的地。
- **挤垮 TCP 会话**：无控制的 UDP 发送方会引入高丢包率，引起 TCP 发送方大大减小它们的速率。

**使用 UDP 的原因：**

- 关于发送什么数据以及何时发送的应用层控制更为精细。
  - 只要应用进程将数据传递给 UDP，就会将此数据打包进 UDP 报文段并立即传递给网络层。
  - TCP 有拥塞控制机制，会遏制运输层 TCP 发送方。并会重新发送数据直到目的主机确认。
  - 实时应用要求<u>最大的发送速率</u>，<u>不希望过分延迟报文段传送</u>，且能<u>容忍一些数据丢失</u>。
- 无须连接建立。
  - UDP 无需握手即可进行数据传输。
  - 不会引入建立连接的时延。
- 无连接状态。
  - TCP 需要在端系统中维护连接状态。
    - 接收和发送缓存
    - 拥塞控制参数
    - 序号与确认号的参数
  - UDP 不维护连接状态，也不跟踪这些参数。
- 分组首部开销小。 
  - 每个 TCP 报文段都有 **20** 字节的首部开销。
  - UDP 报文段只有 **8** 字节的开销。

**使用 UDP 的应用：**

- SNMP 网络管理应用程序
  - 通常在该网络处于重压状态时运行。
  - 可靠的、拥塞受控的数据传输难以实现。
- DNS
  - 避免 TCP 的连接创建时延。

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724173804780.png" alt="image-20220724173804780" style="zoom:80%;" />

**使用 UDP 的应用可能实现可靠数据传输。**

- 可通过在应用程序自身中建立可靠性机制（如确认与重传机制）来完成。
- Chrome 浏览器使用 **QUIC 协议**。在 UDP 之上的应用层协议中实现了可靠性。
- 因此，应用进程可以进行可靠通信，而无需受制于由 TCP 拥塞控制机制强加的传输速率限制。

### 3.1 UDP 报文段结构

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724174640864.png" alt="image-20220724174640864" style="zoom:80%;" />

数据字段：应用层数据。

首部：4个字段。每个字段由两个字节组成。

- 长度字段：UDP 报文段的字节数（首部 + 数据）。
- 检验和字段：接收方用于检查报文段中是否出现了差错。
  - 计算检验和时，除了 UDP 报文段还包括了 IP 首部的一些字段。
- 源端口号
- 目的端口号

###  3.2 UDP 检验和

UDP 检验和提供了差错检测功能。

用于确定 UDP 报文段从源到目的地移动时，其中的比特是否发生了改变。

① 发送方的 UDP 对报文段中的所有 16 比特字的**和**进行**反码**运算，溢出被丢弃，得到的结果即为检验和。

② 接收方，全部的 4 个 16 比特字（包括检验和）加在一起。

如果分组中没有引入差错，那么和应为 **全1**。



**为什么 UDP 提供了检验和：**

- 不能保证源和目的之间的所有链路都提供差错检测。
- 即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。

**端到端原则**：某些功能必须基于端到端实现。

- 与 在较高级别提供这些功能的代价相比，在较低级别上设计的功能可能是冗余的或几乎没有价值的。

在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，UDP 必须在**端到端基础**上在运输层提供差错检测。



UDP 提供差错检测，**但无法从差错中恢复过来**。

- UDP 的某种实现只是丢弃受损的报文段。
- 其他实现是将受损的报文段交给应用程序并给出警告。



## 4. 可靠数据传输原理

可靠数据传输的实现问题不仅在运输层出现，也会在链路层以及应用层出现。

TCP 是在不可靠的 端到端网络层（IP）上实现的可靠数据传输协议。

底层信道模型：将较低层直接视为不可靠的点对点信道。

- 底层信道不会对分组重排序。

单向数据传输：

- 协议也需要在发送端和接收端两个方向上传输分组。
- 除了交换含有待传送的数据的分组之外，还要交换控制分组。

### 4.1 构造可靠数据传输协议

#### 1. 经完全可靠信道的可靠数据传输

rdt 1.0：底层信道是完全可靠的。

rdt 1.0 发送方和接收方的有限状态机（Finite-State Machine，FSM）：

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724182029624.png" alt="image-20220724182029624" style="zoom:80%;" />

`rdt_send(data)` 由较高层应用的过程调用产生。

- `make_pkt(data)`产生一个包含该数据的分组。
- `udt_send()` 向下层发送分组。

`rdt_rcv(packet)` 由较低层协议的过程调用产生。

- `extract(packet, data)` 从分组中取出数据。
- `deliver_data(data)` 将数据上传给较高层。

完全可靠的信道，接收端就不需提供任何反馈信息给发送方，因为不必担心出现差错。

**接收方接收数据的速率能够与发送方发送数据的速率一样快。**



#### 2. 经具有比特差错信道的可靠数据传输

- 分组中的比特可能受损。
- 但不会丢失。
- 假定所有发送的分组将按其发送的顺序被接收。

**自动重传请求（Automatic Repeat reQuest，ARQ）协议**：

使用 **肯定确认** 和 **否定确认** 控制报文，让发送方知道哪些内容被正确接收， 哪些内容接收有误需要重复，基于这样重传机制 的可靠数据传输协议。

ARQ 协议中的三种协议功能：

- **差错检测。**
  - 要求有额外的比特从发送方发送到接收方。
  - 这些比特将被汇集在  rdt 2.0 数据分组的 **分组检验和**字段中
- **接收方反馈**。
  - 发送方了解接收方情况的唯一途径，就是接收方提供明企鹅的反馈信息给发送方。
  - 肯定确认 ACK，否认确定 NAK
  - 理论上，这些分组只需要 1 bit，0 表示 NAK，1 表示 ACK。
- **重传**。
  - 接收方收到有差错的分组时，发送方将重传该分组。

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724191809588.png" alt="image-20220724191809588" style="zoom:80%;" />

①等待来自上层的调用：

`rdt_send(data)` 

- `make_pkt(data)`产生一个包含该数据的分组，**带有检验和**。
- `udt_send()` 向下层发送分组。

②发送方协议等待来自接收方的 ACK 或 NAK 分组。

- `rdt_rcv(rcvpkt) && isACK(rcvpkt)`收到 ACK 分组
  - 协议返回到 ① 状态。
- `rdt_rcv(rcvpkt) && isNAK(rcvpkt)` 收到 NAK 分组
  - 协议重传上一个分组并等待接收方回送的 ACK 和 NAK。
  - **当发送方处于等待 ACK 或 NAK 状态时，不能从上层获得更多的数据。** 

**停等协议**：发送方不会发送新数据，除非发送方确信接收方已正确接收当前分组。

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724191821751.png" alt="image-20220724191821751" style="zoom:80%;" />

rdt 2.0 的致命错误：==**ACK 或 NAK 分组可能受损。**==

处理受损的 ACK 和 NAK：

- ~~引入新型分组。但是新型分组也可能产生差错。~~
- 增加足够的检验和比特。使发送方可以检测差错并从中恢复。
  - 对于会**产生差错但不丢失分组**的信道可行。
- 发送方收到可能受损的 ACK 或 NAK 分组时，重传当前数据分组。
  - 在发送方到接收方的信道中引入了 **冗余分组**
  - 接收方无法事先知道收到的分组是新的还是一次重传。

通过在数据分组中添加一新字段，让发送方对其==**数据分组编号**==，即将发送数据分组的序号放在该字段。

接收方只需检查序号即可确定收到的分组是否是一次重传。

- 停等协议只需 1 bit 的序号。
- 因为假定信道不丢分组，ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方知道是为响应其最近发送的数据分组而生成的。

**ACK 、NAK 分组可能受损：**

##### 协议 rdt2.1 

发送方和接收方的 FSM 状态数是以前的两倍。是因为**协议状态必须反映出分组的序号是0还是1。**

rdt 2.1 使用了从接收方到发送方的**肯定确认**和**否定确认**。

- 接收方发送确认报文时，无需包括所确认的分组序号。

##### rdt 2.2

rdt 2.2 是在有比特差错的信道上实现的一个**无 NAK** 的可靠数据传输协议。

- 不发送 NAK，可以通过==向**上次正确接收的分组**发送 **ACK** 实现。==
- 发送方接收到对同一个分组的 两个 ACK（冗余 ACK）后，就知道接收方没有正确接收 被确认两次的分组之后的分组。
- **接收方发送一个 ACK 报文时，必须包括所确认的分组序号。**

![image-20220724210151143](C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724210151143.png)

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724205913305.png" alt="image-20220724205913305" style="zoom:80%;" /><img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724210311443.png" alt="image-20220724210311443" style="zoom:80%;" />

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724210411659.png" alt="image-20220724210411659" style="zoom:80%;" />

#### 3. 经具有比特差错的丢包信道的可靠数据传输

- 比特会受损
- 底层信道会丢包

**rdt 3.0 ：在可能出错和丢包的信道上的可靠传输。**

也称**比特交替协议**：分组序号在 0 和 1 之间交替。

让**发送方**负责检测和恢复丢包工作。

- 发送方传输一个数据分组，**分组**或者**接收方对该分组的 ACK **发生了丢失。发送方都将收不到响应。
- 发送方等待一个特定的时间后未收到 ACK，可以确定分组已丢失，则**只需要重传该数据分组即可。**

**等待的时间**：发送方与接收方之间的一个**往返时延** + 接收方**处理一个分组**所需时间。

- **冗余数据分组**：如果一个分组经历了一个特别大的时延，发送方可能会重发该分组，即使数据分组和 ACK 都没有丢失。
- rdt 2.2 可用序号解决冗余分组的情况。

使用 rdt 2.2 的 **检验和、序号、 ACK 分组 和 重传**，我们可以在丢包发生后进行处理。

为了实现基于时间的重传机制，需要一个 **倒计数定时器**。

发送方需要做到：

1. 每次发送一个分组时，便启动一个定时器。
2. 响应定时器中断。
3. 终止定时器。

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724212620773.png" alt="image-20220724212620773" style="zoom:80%;" />

由于发送时延与传播时延，一个分组的接收时间必定迟于一个分组的发送时间。

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724212915614.png" alt="image-20220724212915614" style="zoom:80%;" />

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220724212931869.png" alt="image-20220724212931869" style="zoom:80%;" />

实现可靠数据传输协议的技术：

- **检验和**：确定分组数据是否发生损坏。

- **肯定和否定确认**：确定发送至接收方的分组是否出错。出错重传。

- **序号**：检测分组冗余，是否是一次重传。

- **定时器**：确定分组是否丢失，超时进行重传。

  



