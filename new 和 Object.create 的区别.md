### new 和 Object.create 的区别

- 通过 new 创建构造函数实例
  - 首先，会将实例的 [[Prototype]] 指针指向构造函数的原型属性，因此实例可以访问到原型上的方法。
  - 其次，实例对象会执行构造函数体，获得构造函数定义的属性。
- 通过 Object.create 创建的实例
  - 会将实例的[[Prototype]]指针指向传入的原型对象
  - 而不执行原型对象所指向的构造函数的函数体
  - 因此只能访问原型上的方法，而不具有构造函数定义的属性

### JavaScript 继承

####  1.原型链继承

- 通过将子类的原型对象改写为父类实例，实现访问父类原型上的属性和方法。
  - 因为父类实例具有指向父类原型的内部指针。

- 缺点：
  - 创建子类实例，不能向父类的构造函数传参。
  - 原型中引用类型的属性将被所有实例共享。
  - 需要修复子类原型对象的 [[Constructor]] 指向，否则无法通过 instanceOf 和 isPrototypeOf 检查。

#### 2.借用构造函数

- 通过在子类构造函数中调用父类构造函数，执行父类构造函数体，获得属性。
- 优点：
  - 解决了原型链继承。原型上引用类型的属性会被共享的问题。
  - 可以向父类构造函数传参。
- 缺点：
  - 借用构造函数不能访问父类原型上的方法。
  - 方法只能在子类中定义，无法复用。

#### 3.组合继承

将原型链与借用构造函数组合在一起。

- 使用原型链实现对原型属性和方法的继承。
- 通过借用构造函数实现对实例属性的继承。

- 缺点：
  - 两次调用构造函数

#### 4.原型式继承

```js
function object(o){
	funtion F(){}
	F.prototype = o
	return new F();
}
```

- ES5 中新增的 Object.create() 方法规范了原型式继承。
  - 接收两个参数：用作新对象原型的对象，可选的为新对象定义额外属性的对象。
- 使用场景：
  - 不想创建构造函数，只是想让一个对象与另一个对象保持类似。
- 缺点：
  - 传入对象的引用类型属性将会被继承的对象共享

#### 5.寄生式继承

与原型式继承紧密相关。

```js
function object(o) {
	function F(){}
	F.prototype = o;
	return new F();
}

function createAnother(original){
	var clone = object(original);
  // 给克隆的对象增加新的方法。
	clone.sayHi = function(){
		console.log('hello')
	}
	return clone;
}
```

- 缺点：
  - 为对象添加的方法无法复用

