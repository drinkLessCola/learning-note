# 垃圾回收

## 

垃圾：无任何引用的对象

回收：清空被垃圾占用的内存

垃圾回收区域：堆内存

发生在程序空闲的时间

## 识别垃圾

### 引用计数

堆中的每个对象都有一个引用计数器，当一个对象被初始化赋值之后，变量计数设置为1，

当被一个新的变量引用时，计数值增一。

引用解除后，计数值减一。

当计数值为0时，对象就失去了所有的引用，成为了垃圾。

#### 优点

实现简单，判定效率高，无延迟，对程序不被长时间打断的实时环境比较有利。

#### 缺点

赋值时需要更新计数器，增加了微量时间开销

**无法处理循环引用的问题**

可以通过在循环引用时使用弱引用 / 手动解除解决。

### 根搜索算法

GC Roots Set 可访问的引用集合，其中的引用变量可以用于访问对象的属性以及调用对象的方法。

通过一系列 GC Roots 的对象作为起点，遍历寻找对应的引用结点，再通过这些节点继续递归向下查找。

搜索走过的路径称为引用链，当一个对象与 GC Roots 没有任何引用链相连时，证明该对象为垃圾。

#### 可以作为根结点的对象：

- 正在运行的栈上的引用变量
  - 运行在栈上的对于内存来说是已知的 。
- 所有的全局对象，全局变量
- 所有的内置对象
  - 这两个是始终存在的。

GC判断对象是否可达看的是强引用。

## V8的垃圾回收器

Orinoco。

垃圾回收器在进行标记或者回收时，都会**暂停 JS 主线程的执行。**

因此早期 Orinoco 采用了 stop-the-world 的方式。



任何垃圾回收器都有一些必须定期执行的基本任务：

- 识别活 / 死对象。
- 回收 / 重用死对象占用的内存
- 压缩 / 碎片整理内存 （可选）

可以按顺序或任意交错执行。

stop-the-world 的方式暂停 JavaScript 执行并在主线程上按顺序执行这些任务。

副作用是会导致主线程出现卡顿 和 延迟，用户感知明显。



### 过程

- 标记存活对象。通过根搜索算法验证活跃对象的可达性，收集任何无法访问的对象。
- 清空无法访问对象对应的内存空间。同时在一个 **free-list** 的列表记录这些清理出来的内存位置和大小，当有新的对象需要分配空间时，就会在 free-list 中查找。



### V8中的堆内存区域划分

将堆内存划分为两个区域，新生代 Young Generation 和 老生代 Old Generation。

- 新生代用于存储生命短暂的对象，如执行上下文。
- 老生代用于存储生命漫长的对象，如函数声明。

新生代又被进一步划分为两个区域 Nursery / Intermediate。



**The Generational Hypothesis** 

V8的内存区域分布 基于大多数对象都会在新生代中死亡的预测。

只有少数对象能够在新生代中存活下来，移动到老生代中。

因此， GC复制算法得以在 V8 中被使用，因为被复制的对象一定是少数。



### Major GC (Full Mark-Compact)

用于回收老生带的垃圾。

采用了 Mark-Compact 标记整理算法。

是为了解决 Mark-Sweep 标记清除算法带来的内存缝隙提出的优化方案。

标记仍然是通过根搜索算法。



**Compact**

- 将存活的对象移动到该去的位置
- 修改引用，让他们指向新的地址

### Minor GC (Scaverger)

Minor GC 专门用于管理新生代内存，

并且使用了一种名为**cheney 的 GC 复制算法**，使用空间换取时间的方式。

#### 为什么使用复制算法

因为随着程序的运行，新生代会产生大量的内存占用，如果采用简单的遍历手段来清理，时间效率就会大打折扣。

#### 空间复制算法

将新生代空间**均等**一分为二：**From-space** 和 **To-space**。

新的对象产生之后，会首先占用 From-space。

当

From-space 达到了某个阈值，就会开始执行清理任务。

通过根搜索算法找到 **活动对象**，

将剩余的活动对象复制到 To-space。

然后将 From-space 全部清空，将两个空间互换，得到一个全新的 To-space

#### 与标记清除算法相比较

#### 优势

- 时间上效率更高，并且当堆中的对象越多，GC复制算法的优势就越大。
- 不需要维护一个 free-list 来记录分配空间，只需要一个指针来记录可分配空间的首地址。
- 不会产生内存碎片。无需整理。

许多 CPU 会借助缓存机制，通过压缩把**有引用关系的对象**安排在堆中较近的位置，（局部性原则？）以达到高速访问对象的目的。

#### 缺点

内存的使用效率偏低，新生代中只有一半的内存空间可供分配。

使用**深度优先搜索**时，需要递归去查询和复制子对象。

- 持续地占用栈内存，使用队列迭代算法优化。
  - 使用另外一个 scan 指针，来辅助广度优先算法。
- 不断产生新的执行上下文，可以使用尾递归优化。

因此 Cheney 算法采用的是 **广度优先遍历**，scan 与 free 之间的对象成为了一个队列，把堆用作队列，消除了普通 GC算法的递归风险，不用特意为队列留出多余空间就能完成遍历。

代价是 不再考虑临近的对象放在一起，访问速度上与普通的 GC 算法相比会稍慢一点。



新生代中的对象如果能在两次 GC 中存活下来，就会被疏散到老生代区域中。