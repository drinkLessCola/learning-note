# 正则表达式

## 模式 Patterns 和修饰符 flags

### 正则表达式

正则表达式包括 **模式** 和可选的 **修饰符**

有两种创建正则表达式对象的语法：

```js
regexp = new RegExp("pattern", "flags")
regexp = /pattern/	// 没有修饰符
regexp = /pattern/gmi 	// 带有修饰符 g、m、i
```

两种情况下，`regexp` 都会成为内建类 `RegExp` 的一个实例。

它们的主要区别为：

- 使用斜线 `/.../` 的模式不允许插入表达式（如 `${...}`），它是完全静态的

- 当需要使用 动态生成的字符串 创建正则表达式时，更经常使用 `new RegExpl

  ```js
  let tag = prompt("What tag do you want to find?", "h2")
  let regexp = new RegExp(`<${tag}>`)
  ```

### 修饰符

在 JavaScript 中，有 6 个修饰符：

- `i`  ignoreCase 搜索不区分大小写
- `g` global 搜索时会寻找所有的匹配项，没有则只返回第一个匹配项
- `m` multiline 多行模式
- `s`  dotAll 启用 “dotall” 模式，允许 `.` 匹配换行符 `\n`
- `u` unicode 开启完整的 Unicode 支持。该修饰符能够正确处理代理对。
- `y` sticky 粘滞模式，在文本中的确切位置搜索

没有修饰符和特殊符号，那么正则表达式的搜索和子字符串的搜素相同

### 搜索： str.match

 将正则表达式和字符串方法结合一起使用。

`str.match(regexp)` 方法在字符串 `str` 中寻找 `regexp` 的所有匹配项。

它有三种工作模式：

1. 如果正则表达式具有修饰符 `g`，它返回一个由**所有匹配项**所构成的数组：

   ```js
   let str = "Abab"
   console.log( str.match(/ab/gi)) // ['Ab', 'ab'] 字符串组成的数组
   ```

2. 如果没有 `g`，那么会以**数组**形式返回第一个匹配项，索引 `0` 处保存着完整的匹配项，返回的结果的属性中还有一些其他详细信息：

   - `index` 匹配项的位置
   - `input` 原字符串

   ```js
   let str = "Abab"
   let result = str.match(/ab/i) 
   
   result[0] // 'Ab'
   result.length // 1
   result.index // 0 匹配项的位置
   result.input // Abab 原字符串
   ```

3. 如果没有匹配项，**则返回 `null`（无论是否有修饰符 `g`）**

   ```js
   let matches =  "JavaScript".match(/HTML/);
   if(!matches.length) { 
     // Error: Cannot read property 'length' of null
   	...
   }
   ```

   如果希望结果始终是一个数组，可以：

   ```js
   let matches =  "JavaScript".match(/HTML/) || []
   ```

### 替换 str.replace

`str.replace(regexp, replacement)` 方法使用 `replacement` 替换在字符串 `str` 中找到的 `regexp` 的匹配项

- 如果带有修饰符 `g`，则替换所有匹配项
- 否则只替换第一个

```js
"Abab".replace(/ab/i,'cd') //cdab
"Abab".replace(/ab/ig, 'cd') //cdcd
```

可以在 `replacement`  中使用特殊的字符组合来对匹配项进行插入：

|              | Symbols  | Action in the replacement string              |
| ------------ | -------- | --------------------------------------------- |
| lastMatch    | $&       | 最后匹配的字符串                              |
| leftContext  | $`       | lastMatch 左侧的字符串                        |
| rightContext | $‘       | lastMatch 右侧的字符串                        |
|              | $n       | 如果 n 是1~2位的数字，则为第 n 个匹配的捕获组 |
|              | $\<name> | 给定名字的捕获组的内容                        |
|              | $$       | 插入字符 $                                    |
| lastParen    | $+       | 最后匹配的捕获组（非标准特性）                |
| input        | $_       | 最后搜索的字符串（非标准特性）                |

```js
"I love HTML".replace(/HTML/, "$& and JavaScript") 
// I love HTML and JavaScript
```

### 测试：regexp.test

`regexp.test(str)` 方法寻找至少一个匹配项，如果找到了，返回 `true`，否则返回 `false`

```js
let str = "I love JavaScript"
let regexp = /LOVE/i

regexp.test(str) // true
```



## 字符类

**字符类（Character classes）**是一种特殊的符号，匹配特定集合中的任何符号。

- `\d` digit 数字类，对应于【任何一位数字】
- `\s` space 空格符号
  - 包括空格，制表符 `\t`，换行符 `\n` 
  - 和其他少数稀有字符，如 `\v`、`\f`和 `\r`
- `\w` word 单字字符：
  - **拉丁字母( 即英文字母 ) / 数字 / 下划线 `_`**
  - 非拉丁字母不属于 `\w`

使用 `\d`：

```js
// 找到电话号码的第一个数字
let str = "+7(903)-123-45-67"
let regexp = /\d/
str.match(regexp) // 7

// 添加修饰符 g 来查找所有数字
let regexp = /\d/g
str.match(regexp) // 匹配项构成的数组：[7,9,0,3,1,2,3,4,5,6,7]
str.match(regexp).join('') 
```

 `\d\s\w` 表示 数字 后跟 空格字符，后跟 单字字符。 如 `1 a`

**正则表达式可以同时包含常规符号和字符类**。

- `CSS\d` 匹配 CSS 后带一个数字的字符串

可以使用更多字符类：

```JS
“I love HTML5".match(/\s\w\w\w\w\d/) // ' HTML5'
```

### 反向类

对于每个字符类，都有一个反向类：用相同的字母表示，但是大写的。

反向表示它与所有其他字符匹配。

- `\D` 非数字：除 `\d` 以外的任何字符
- `\S` 非空格符号： 除 `\s` 以外的任何字符
- `\W` 非单字字符： 除 `\w` 以外的任何字符，如非拉丁字母或空格

创建一个只包含数字的电话号码的另一种快捷方式：

- 查找非数字 `\D` 并将其从字符串中删除 

```js
let str = "+7(903)-123-45-67"
str.replace(/\D/g, "") // 79031234567
```

### 点（.）匹配 “任何字符”

点 `.` 是一种特殊字符类，它与 “**除==换行符==之外的任何字符**” 匹配

```js
"Z".match(/./) // Z

let regexp = /CS.4/
"CSS4".match(regexp) // CSS4
"CS-4".match(regexp) // CS-4
"CS 4".match(regexp) // CS 4
```

必须有一个与之匹配的字符，不能是“缺少字符”。

```js
"CS4".match(/CS.4/) // null 没有匹配项
```

#### 带有修饰符 “s” 时点字符类匹配任何字符

默认情况下，点与换行符 `\n` 不匹配

```js
“A\nB".match(/A.B/) // null
```

如果一个正则表达式具有 `s` 修饰符，那么点 `.` 能够匹配任何字符：

```js
“A\nB".match(/A.B/s) // A\nB 匹配了！
```

##### IE 浏览器不支持 s 修饰符

替代方案：使用 `[\s\S]` （空格字符 / 非空格字符）来匹配 ”任何字符“。

```JS
“A\nB".match(/A[\s\S]B/s) // A\nB 匹配了！
```

- 也可以用另一对互补的类：`[\d\D]`
- 甚至是 `[^]` 匹配任何字符，除了什么都没有

如果我们希望两种点都使用相同的模式，可以使用此技巧：

- 实际的点 `.` 表现常规方式（不包括换行符）
- 带有 `[\s\S]` 或类似形式匹配 “任何字符”

##### 注意空格

```js
"1 - 5".match(/\d - \d/) // 1 - 5
"1 - 5".match(/\d\s-\s\d/) // 1 - 5
```

**一个空格也是一个字符。**

### 总结

存在以下字符类：

- `\d` —— 数字。
- `\D` —— 非数字。
- `\s` —— 空格符号，制表符，换行符。
- `\S` —— 除了 `\s` 。
- `\w` —— 拉丁字母，数字，下划线 `'_'`。
- `\W` —— 除了 `\w`。
- `.` —— 带有修饰符 `'s'` 时匹配任何字符，否则匹配除换行符 `\n` 之外的任何字符。

## Unicode：修饰符 “u” 和类 \p{…}

JavaScript 对字符串使用 **Unicode 编码**。

- length 会将 4 个字节长的字符当作 2 个 2 字节长的字符。
- 默认情况下，正则表达式也会把一个 4 字节的 “长字符” 当成一对 2 个字节长的字符。

正则表达式可以通过 修饰符 `u` 被用以解决此类问题。

同时也能够使用 Unicode 属性进行查找了。

### Unicode 属性 \p{…}

Unicode 中的每个字符都有很多属性。描述了字符所属的 “类别”，包含了关于字符的各种信息。

- 如果一个字符具有 `Letter` 属性，这意味着这个字符归属于（任意语言的）字母表。
-  `Number` 属性则表示这是一个数字：可能是阿拉伯数字 / 中文数字

我们可以查找具有某种属性的字符，写作 `\p{...}`。

**为了使用 `\p{...}`，一个正则表达式必须使用修饰符 `u` 来启用对 Unicode 的支持。**

`\p{Letter}` ：表示任何语言中的一个字母。也可以使用别名 `\p{L}`

```js
let str = "A ბ ㄱ"

str.match(/\p{L}/gu)
str.match(/\p{L}/g/)
```

主要的字符类和它们对应的子类别：

- 字母（Letter）`L`：
  - 小写（lowercase） `Ll`
  - 修饰（modifier）`Lm`
  - 首字母大写（titlecase）`Lt`
  - 大写（uppercase）`Lu`
  - 其它（other）`Lo`
- 数字（Number） `N`:
  - 十进制数字（decimal digit）`Nd`
  - 字母数字（letter number）`Nl`
  - 其它（other）`No`
- 标点符号（Punctuation）`P`:
  - 连接符（connector）`Pc`
  - 横杠（dash）`Pd`
  - 起始引号（initial quote）`Pi`
  - 结束引号（final quote）`Pf`
  - 开（open）`Ps`
  - 闭（close）`Pe`
  - 其它 `Po`
- 标记（mark）`M` (accents etc)
  - 间隔合并（spacing combining）`Mc`
  - 封闭（enclosing）`Me`
  - 非间隔（non-spacing）`Mn`
- 符号（Symbol）`S`
  - 货币（currency）`Sc`
  - 修饰（modifier）`Sk`
  - 数学（math）`Sm`
  - 其它（other）`So`
- 分隔符（Separator）`Z`
  - 行（line）`Zl`
  - 段落（paragraph）`Zp`
  - 空格（space）`Zs`
- 其它（Other）`C`
  - 控制符（control）`Cc`
  - 格式（format）`Cf`
  - 未分配（not assigned）`Cn`
  - 私有（private use）`Co`
  - 代理伪字符（surrogate）`Cs`

也有其他派生的类别：

- `Alphabetic`（`Alpha`）：包含了字母 `L`，加上字母数字`Nl`（如 Ⅻ）
-  `Other_Alphabetic`（`OAlpha`）：`Alpha` 加上一些其他符号
- `Hex_Digit` 包括 16 进制数字 `0-9`，`a-f`



Unicode 支持很多不同属性：

- [列出一个字符的所有属性](https://unicode.org/cldr/utility/character.jsp)
- [按照属性列出所有的字符](https://unicode.org/cldr/utility/list-unicodeset.jsp)
- [属性的对应缩写形式](https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt)
- [以文本格式整理的所有 Unicode 字符，包含了所有的属性](https://www.unicode.org/Public/UCD/latest/ucd/)

#### 举例：16 进制数字

查找 16 进制数字，写作 `xFF` 

一个 16 进制数字：`\p{Hex_Digit}`

```js
let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u
"xAF".match(regexp) //xAF
```



#### 举例：中文字符

有一个 Unicode 属性 `Script`，这个属性可能有一个值：`Cyrillic`、`Greek`、`Arabic`、`Han`（中文）（[完整列表](https://en.wikipedia.org/wiki/Script_(Unicode))）。

要在给定的书写系统中查找字符，我们需要使用 `Script=<value>`

- 西里尔字母：`\p{sc=Cyrillic}`
- 中文象形文字：`\p{sc=Han}`

```js
let regexp = /\p{sc=Han}/gu // 返回中文象形文字
let str = `Hello Привет 你好 123_456`

str.match(regexp) // ["你","好"]
```

#### 举例：货币

表示货币的字符，例如 `$`、`€` 和 `¥`，具有 Unicode 属性 `\p{Currency_Symbol}`，缩写为 `\p{Sc}`。

用它来查找格式为 “货币，接着是一个数字“ 的价格：

```js
let regexp = /\p{Sc}\d/gu
let str = `Prices: $2, €1, ¥9`

str.match(regexp) // ['$2','€1','¥9']
```

### 总结

修饰符 `u` 表示启用正则表达式中对 Unicode 的支持

- 4 个字节长的字符被以正确的方式处理：被看成单个字符
- Unicode 属性可以被用于查找：`\p{...}`

有了 unicode 属性，我们可以查找 **给定语言中的词，特殊字符（引用，货币）**等等。

## 锚点：字符串开始 ^ 和结尾 $

插入字符 `^`  和美元符号 `$` 在正则表达式中具有特殊的含义。被称为 “锚点”

- `^` 匹配文本开头
- `$` 匹配文本末尾

```js
let str1 = "Mary had a little lamb"
/^Mary/.test(str1) // true

let str2 = "it's fleece was white as snow"
/snow$/.test(Str2) // true 
```

以上这些特殊的例子，我们实际上可以使用 `startsWith / endsWith` 来替代。



### 测试完全匹配

这两个锚点 `^...$` 放在一起通常被用于测试一个字符串是否完全匹配一个模式。

- 如检查用户输入的格式是否正确

**eg.** 测试一个字符串是否是 `12:34` 格式的时间。

```js
let goodInput = "12:34"
let badInput = "12:345"

let regexp = /^\d\d:\d\d$/
regexp.test(goodInput) // true
regexp.test(badInput)	 // false
```

**如果有修饰符 `m`，那么锚点的行为将会不同。**

### 锚点“宽度”为零

锚点 `^` 和 `$` 属于测试。它们的宽度为 0。

换句话说，它们并不匹配一个具体的字符，而是让正则引擎测试所表示的条件（文本开头 / 文本末尾）

### 正则表达式 ^$

空字符串是 `^$` 唯一的匹配项：开始并立即结束。

 

## 锚点 ^ $ 的多行模式，修饰符 “m”

多行模式由修饰符 `m` 启用。 

它只影响 `^`  和 `$` 的行为。

**在多行模式下，它们不仅仅匹配文本的开始与末尾，还匹配每一行的开始与末尾。**

### 搜索行的开头 ^

模式 `/^\d+/gm` 将从每行的开头取一个数字：

```js
let str = `1st place: Winnie
2nd place: Piglet
3rd place: Eeyore`

str.match(/^\d/gm) // 1, 2, 3
```

没有修饰符 `m` 时只会匹配第一个数字。

- 这是因为默认情况下，锚点 `^` 仅匹配文本的开头
- 在多行模式下，它匹配行的开头

 **行的开头 **表示 “在换行符之后”：多行模式下的测试 `^` 匹配所有以换行符 `\n` 开头的位置，以及文本开始的位置。

### 搜索行的末尾 $

正则表达式 `\d$` 寻找每行的最后一个数字

```js
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

str.match(/\d$/gm)
```

没有修饰符 `m`，那么美元符 `$` 将只会匹配整个文本的末尾。

**行的末尾**表示“在换行符之前”：多行模式下的测试 `$` 匹配换行符 `\n` 后接的所有位置，以及在文本末尾的位置。



### 搜索 \n 而不是 ^ $

要寻找新的一行，不仅可以使用锚点，也可以使用换行符 `\n`。

使用 `\d\n` 进行搜索而不是使用 `\d$`：

```js
let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

str.match(/\d\n/g) // ['1\n','2\n']
```

两种方式的区别：

- 这里只有 2 个匹配项，因为在 3 之后没有换行符。
  - 由于这里是文本末尾，所以它匹配 `$`。
- 每个匹配项都包含了一个换行符 `\n`。
  - 锚点不包含，因为它只测试条件。
  - 而 `\n` 是一个字符，因此它成为了结果的一部分。

因此，当我们需要结果中有换行符时，使用 `\n`。而锚点则用于在行的开头 / 末尾查找某些内容。

## 词边界：\b

词边界 `\b` 也是一种检查，与 `^` 和 `$` 一样。

当正则表达式引擎遇到 `\b` 时，它会检查<u>字符串中的位置</u>是否是**词边界**。

**有三种不同的位置可作为词边界：**

- 在字符串开头，如果第一个字符是单词字符 `\w`
- 在字符串中的两个字符之间，其中一个是单词字符 `\w`，另一个不是
- 在字符串末尾，如果最后一个字符是单词字符 `\w`

```js
// 找到独立的单词 Java
"Hello, Java!".match(/\bJava\b/) 			// Java
"Hello, JavaScript!".match(/\bJava\b/) // null
```

在字符串 `Hello, Java!`  中，以下位置对应于 `\b`

<img src="C:\Users\Zirina\AppData\Roaming\Typora\typora-user-images\image-20220806212325638.png" alt="image-20220806212325638" style="zoom:80%;" />

```js
"Hello, Java!".match(/\bHello\b/) // Hello
"Hello, Java!".match(/\bJava\b/)  // Java
// l 之后没有单词边界。
"Hello, Java!".match(/\bHell\b/)  // null（无匹配项）
// 因为感叹号不是单词字符 \w，所以其后没有词边界
"Hello, Java!".match(/\bJava!\b/) // null（无匹配项）
```

`\b` 既可以用于单词，也可以用于数字。

模式 `\b\d\d\b` 查找独立的两位数。

- 查找的是两位数
- 其周围是与 `\w` 不同的字符，如空格 / 标点符号 / 文本开头 / 结尾

```js
"1 23 456 78".match(/\b\d\d\b/g) // 23,78
"12,34,56".match(/\b\d\d\b/g) 	 // 12,34,56
```

#### 词边界不适用于 非拉丁字母

词边界测试 `\b` 检查该位置的一侧是否匹配 `\w`，而另一侧则不匹配`\w`。

`\w` 表示拉丁字母 `a-z`  / 数字 / 下划线，

因此检查不适用于其他字符，如西里尔字母（cyrillic letters）或象形文字（hieroglyphs）。



## 转义，特殊字符

反斜杠 `\` 用于表示字符类，例如 `\d`。它是正则表达式中的一个特殊字符。

还存在其他的特殊字符，例如 `[] {} () \ ^ $ . | ? * +`，用于执行更强大的搜索。

### 转义

**要将特殊字符用作常规字符**，请在其前面加上反斜杠：`\.`。

```js
"Chapter 5.1".match(/\d\.\d/) // 5.1
// 括号也是特殊字符
"function g()".match(/g\(\)/) // g()
// 要查找反斜杠，应该使用两个反斜杠
"1\\2".match(/\\/); // '\'
```

### RegExp 字面量：一个斜杠

斜杠符号 `'/'` 并不是一个特殊字符，但被用于在 Javascript 中**开启和关闭正则匹配**：`/...pattern.../`，**所以也需要被转义**。

使用 `\/` 进行转义。

```js
"/".match(/\//) // '/'
```

如果是使用 `new RegExp`  的方式创建正则表达式，则不需要转义斜杠：

```js
"/".match(new RegExp("/"))
```

### new RegExp

使用 `new RegExp`  的方式创建正则表达式，不必转义 `/`。

但需要进行一些其他转义。

```js
let reg = new RegExp("\d\.\d")

"Chapter 5.1".match(reg) // null
"Chapter 5.1".match(/\d\.\d/) // 5.1
```

**反斜杠会被字符串消耗：**

- 常规字符串有自己的特殊字符，如 `\n`，反斜杠用于转义。
- 因此 “\d\.\d” 实际上是 “d.d”

**==在字符串中的反斜杠==** 表示 **转义** 或者类似 `\n` 这种只**能在字符串中使用的特殊字符**。这个引用会消费并且解释这些字符。

- `\n` 变成一个**换行字符**
- `\u1234` 变成该编码所对应的 **Unicode 字符**
- 而当没有特殊含义时，如 `\d` 或者 `\z`，碰到这种情况则会**自动移除反斜杠**。

要修复 `new RegExp` 中的这个问题，我们需要双斜杠，因为引用会把 `\\`  变为 `\`。

```js
let regStr = "\\d\\.\\d"
regStr // \d\.\d

let regexp = new RegExp(regStr)
"Chapter 5.1".match(regexp)	// 5.1
```

### 总结

- 要在 RegExp 字面量中匹配特殊字符 `[ \ ^ $ . | ? * + ( )`，需要在它们的前面加上一个反斜杠 `\`。
- 如果在 `/.../` 内（但不在 `new RegExp` 内），我们还需要转义 `/`
- 当将字符串传递给 `new RwgExp` 时，我们需要双反斜杠 `\\` ，因为字符串引号会消费一个反斜杠。

## 集合和范围 […]

在方括号 `[…]` 中的几个 **字符** 或 **字符类** 表示 **搜索给定字符中的任意一个**。

### 集合

`[eao]` 表示 `'a'` ， `'o'` ， `'e'` 三个字符中的任何一个。

在正则表达式中，可以将集合和常规字符一起使用。

集合中虽然有多个字符，但它们在匹配中**只会对应其中的一个**。

```js
"Mop top".match(/[tm]op/gi) // "Mop", "top"
"Voila".match(/V[oi]la/) // null
```

### 范围

方括号也可以表示 **字符范围**

- `[a-z]` 表示从  `a`  到 `z` 范围内的字符
- `[0-5]` 表示从 `0` 到 `5` 的数字。

eg. 搜索 `x` 后面跟着两个十六进制数。

```js
"Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g/) //xAF
```

`[0-9A-F]` 中有两个范围：搜索一个字符

- 要么是 `0` 到 `9` 范围内的数字
- 要么是 `A` 到 `F` 的字母

如果还想查找小写字母，可以添加范围 `a-f` 或添加标志 `i`。

我们也可以在 `[...]` 中使用字符类。

- 如果想查找单词字符 `\w` 或连字符 `-`，则集合可以写为 `[\w-]`
- 也可以组合多个类，如 `[\s\d]`

#### 字符类的某些字符集合的简写

- `\d` ：和 `[0-9]` 相同
- `\w`：和 `[a-zA-Z0-9_]` 相同
- `\s`：和 `[\t\n\v\f\r ]` 外加少量罕见的 Unicode 空格字符。

### 示例：多语言 \w

由于字符类 `\w` 是简写的 `[a-zA-Z0-9_]`，因此无法找到中文象形文字，西里尔字母等。

我们可以编写一个更通用的模式，该模式可以查找任何语言中的单词字符。

借助 Unicode 属性很容易实现：

`[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`

- `Alphabetic(Alpha)` 字母（字母 + 字母数字）
- `Mark(M)` 音调
- `Decimal_Number(Nd)` 十进制数字
- `Connector_Punctuation(Pc)` 下划线 `_` 和类似的字符
- `Join_Control(Join_C)` 两个特殊代码 `200c` 和 `200d` ，用于连字，例如阿拉伯语。

```js
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu
let str = `Hi 你好 12`

str.match(regexp) // H,i,你,好,1,2
```

#### IE 浏览器不支持 Unicode 属性

 IE 浏览器未实现 Unicode 属性 `p{...}`。如果我们真的需要它们：

- 可以使用库 `XRegExp`。
- 或者使用感兴趣的语言中的字符范围。

### 排除范围

`[^...]` 用于排除范围匹配。

通过在开头添加插入符号 `^`  来表示匹配所有 **除了给定的字符** 之外的任意字符。

- `[^aeyo]` 匹配除了 `a/e/y/o` 之外的任何字符。
- [^0-9] 匹配除了数字之外的任何字符，与 `\D` 作用相同
- `[^\s]` 匹配任何非空格字符，与 `\S` 作用相同。

```js
// 搜索除了字母、数字和空格之外的任何字符
"alice15@gmail.com".match(/[^\d\sA-Z]/gi) // @, .
```

### […] 中的转义

- 通常当我们想要准确地找到一个特殊字符时，需要像 `\.`  这样对其进行转义。
- 如果我们需要反斜杠，那么我们需要使用 `\\`（在 new RegExp 中）。

在方括号，我们可以使用绝大多数特殊字符而无需转义：

- 符号 `. + ( )` 无需转义。
- 在开头或结尾（未定义范围）的连字符 `-` 不会被转义。
- 插入符号 `^` 仅在开头会被转义（表示排除）
- 右方括号 `]` 总是会被转义

换句话说，除了在方括号中有特殊含义的字符外，其它所有的特殊字符都是允许不转义的。

- 方括号中的点 `.` 表示的就是一个点。模式`[.,]` 将会搜索字符之一：点或逗号。
- `[-().^+]` 查找 `-().^+` 中的任何字符

```js
"1 + 2 - 3".match(reg) // 匹配 +, -
// 转义也不会有任何问题，仍然可以正常工作
let reg = /[\-\(\)\.\^\+/g
```

### 范围和修饰符 “u”

如果集合中有代理对，则需要标志 `u` 才能使它们正常工作。

例如，让我们在字符串 `𝒳` 中查找 `[𝒳𝒴]`：

```js
 '𝒳'.match(/[𝒳𝒴]/)  //�
```

结果不正确，因为默认情况下正则表达式 “不知道” 代理对。

正则表达式引擎认为 `[𝒳𝒴]` —— 不是两个字符，而是四个字符：

1. `𝒳` 的左半部分 `(1)`，
2. `𝒳` 的右半部分 `(2)`，
3. `𝒴` 的左半部分 `(3)`，
4. `𝒴` 的右半部分 `(4)`。

因此示例查找并显示了 `𝒳` 的左半部分。

添加上修饰符 `u`，那么行为就正常了。



当我们查找范围时也会出现类似的情况，就像`[𝒳-𝒴]`。

如果忘记添加修饰符 `u`，则会出现错误：

```js
'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression
```

- 没有修饰符 `u` 时， `[𝒳-𝒴]` 被理解为 `[<55349><56499>-<55349><56500>]`。
- 很容易看出范围 `56499-55349` 是无效的：其起始代码 `56499` 大于终止代码 `55349`。

有修饰符 `u` 时，该模式就可以正常匹配了：

```js
'𝒴'.match(/[𝒳-𝒵]/u) // 𝒴
```

### 任务

``` js
// Java 后面没有任何字符
"Java".match(/Java[^script]/) // null
"JavaScript".match(/Java[^script]/) // "JavaS"
```



## 量词 +，*，？ 和 {n}

数字是一个或多个数字 `\d` 的序列。

为了标记我们需要的数量，我们需要加一个 **量词**。

### 数量 {n}

最简单的量词便是大括号中的数字：`{n}`

在一个字符（或一个字符类，或`[...]`）后附加一个量词，用来指出我们具体需要的数量。

- 确切的位数 `{5}`

  - `\d{5}` 表示 5 位数，与 `\d\d\d\d\d` 相同。

  - ```js
    "I'm 12345 years old".match(/\d{5}/) // "12345"
    ```

  - 可以添加 `\b` 来排除位数更多的数字：`\b\d{5}\b`

- 范围：`{3-5}` 匹配 3 - 5 个

  - ```js
    "I'm not 12, but 1234 years old".match(/\d{3,5}/) // "1234"
    ```

  - 可以省略上限 `\d{3,}` 会查找位数大于等于 3 的数字

  - 如果需要一个及以上的数字，就是用 `\d{1,}`

  - ```js
    let str = "+7(903)-123-45-67";
    let numbers = str.match(/\d{1,}/g); // 7,903,123,45,67
    ```

### 缩写

大多数常用的量词都会简写形式：

#### `+`

`+` 代表 **“一个或多个”**，与 `{1,}` 相同。

`\d+` 用来查找所有数字：

```js
let str = "+7(903)-123-45-67";
str.match(/\d+/g) // 7,903,123,45,67
```

#### `?`

`?` 代表 **0 个或 1 个**，与 `{0,1}` 相同。使符号变得**可选**。

```js
// ou?r 查找 o 后跟 0 个或 1 个 u，然后是 r
let str = "Should I write color or colour?"
str.match(/colou?r/g) // color, colour
```

#### `*`

`*`  代表 ” 0个及以上 “，与 `{0,}` 相同。

即字符可以出现任何次数或者不出现。

```js
// \d0* 查找一个数字后面跟着任意数量的 0 的数字：
"100 10 1".match(/\d0*/g) // 100, 10, 1
// \d0+ 要求至少有一个 0
"100 10 1".match(/\d0+/g) // 100, 10
```

### 更多示例

小数的正则表达式（带浮点的数字）：`\d+\.\d+`

```js
"0 1 12.345 7890".match(/\d+\.\d+/g) // 12.345
```

没有特性（attribute）的**打开**的 HTML 标签 的正则表达式

- 最简单的： `/<[a-z]+>/i`

- 进阶版：`/<[a-z][a-z0-9]*>/i`

  - 根据标准，HTML 标签名可以在除了第一个位置之外的任何位置有一个数字，如 `<h1>`

  - ```js
    "<h1>Hi!</h1>".match(/<[a-z][a-z0-9]*>/gi) // <h1>
    ```

打开或关闭的不带特性的 HTML 标签的正则表达式：

`/<\/?[a-z][a-z0-9]*>/gi`

可选的斜杠 `/?`，需要使用反斜杠转义它，否则 会被认为是模式的结束符

```js
"<h1>Hi!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
```

