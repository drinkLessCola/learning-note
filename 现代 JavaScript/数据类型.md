

# 数据类型

## 原始类型的方法

str.toUpperCase()返回一个大写化处理的字符串。

在str.toUpperCase()中实际发生的情况：

1. 字符串str是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，如toUpperCase()
2. 该方法运行并返回一个新的字符串。
3. 特殊对象被销毁，只留下原始值str。

所以原始类型可以提供方法，但它们依然是轻量级的。

==JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。==

toFixed(n)将数字舍入到给定的精度。

### 构造器String/Number/Boolean仅供内部使用

像Java这样的语言允许我们使用new Number(1)或new Boolean(false)等语法，明确地为原始类型创建“对象包装器”。

在JavaScript中由于历史原因也是可以的，但不推荐。

- 对象在if中始终为真（对象转换为boolean hint （在布尔上下文中）始终为true)
- 调用不带new关键字的String/Number/Boolean 函数将一个值转换为相应的类型：转成字符串，数字或布尔值（原始类型）

### null/undefined 没有任何方法

特殊的原始类型null和undefined是例外。它们没有对应的“对象包装器”，也没有提供任何方法。

### 其他

```javascript
let str = "Hello";

str.test = 5; // (*)

alert(str.test);
```

根据你是否开启了严格模式 `use strict`，会得到如下结果：

1. `undefined`（非严格模式）
2. 报错（严格模式）。

为什么？让我们看看在 `(*)` 那一行到底发生了什么：

1. 当访问 `str` 的属性时，一个“对象包装器”被创建了。
2. ==在严格模式下，向其写入内容会报错。==
3. 否则，将继续执行带有属性的操作，该对象将获得 `test` 属性，但是此后，==“对象包装器”将消失==，因此在最后一行，`str` 并没有该属性的踪迹。

**这个例子清楚地表明，==原始类型不是对象。==**

它们不能存储额外的数据。

## 数字类型

在JavaScript中，数字（number)有两种类型：

- JavaScript中的常规数字以64位的格式IEEE-754存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。
- BigInt数字，用于表示任意长度的整数。

### 编写数字的更多方法

十亿 bn

- 10亿 1bn
- 73亿 7.3bn

在JavaScript中，我们通过在数字后面附加字母“e”, 并指定零的数量来缩短数字。

1e9 十亿

1e-6 0.000001

### 十六进制，二进制和八进制数字

255 0xff 0xFF ==大小写没有影响==

二进制和八进制数字系统很少使用，但也支持使用0b和0o前缀

```js
let a = 0b11111111; // 二进制形式的 255
let b = 0o377; // 八进制形式的 255

alert( a == b ); // true，两边是相同的数字，都是 255
```

只有这三种进制支持这种写法，对于其他进制，我们应该使用parseInt。

### toString(base)

num.toString(base)返回在给定base进制数字系统中num的字符串表示形式。

```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

base的范围从2到36。默认情况下是10。

常见用例如下：

base=16 用于十六进制颜色，字符编码等，

base=2 主要用于调试按位操作，

base=36 数字可以是0..9或A..Z。当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的URL，可以简单地使用基数为36的数字系统表示：

```js
alert( 123456..toString(36) ); // 2n9c
```

### 使用两个点来调用一个方法

如果我们想==直接在一个数字上调用一个方法==，那么需要在它后面放置两个点`..`。

### 舍入

- Math.floor 向下舍入：3.1变成3     -1.1变成-2.
- Math.ceil 向上舍入 3.1变成4      -1.1变成-1
- Math.round 向最近的整数舍入： 3.1变成3    3.6变成4   -1.1 变成-1
- Math.trunc (==IE浏览器不支持这个方法==) 移除小数点后的所有内容而没有舍入 3.1 变成 3  -1.1变成-1

#### 将数字舍入到小数点后n位

##### 乘除法

例如要将数字舍入到小数点后两位，可以将数字乘以100，调用舍入函数，然后将其除回。

```js
let num = 1.23456;

alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
```

toFixed(n)将数字舍入到小数点后n位，并以字符串形式返回结果。

```js
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```

==这将会向上或向下舍入到最接近的值，类似于Math.round==

```js
let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
```

==toFixed的结果是一个字符串，如果小数部分比所需要的短，则在结尾添加0==

```js
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000"，在结尾添加了 0，以达到小数点后五位
```

我们可以使用一元加号或Number()调用，将其转换为数字： + num.toFixed(5)

### 不精确的计算

在内部，数字是以 64 位格式 [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985) 表示的，所以正好有 64 位可以存储一个数字：

- 其中 52 位被用于存储这些数字，
- 其中 11 位用于存储小数点的位置（对于整数，它们为零），
- 而 1 位用于符号。

如果一个数字太大，则会溢出64位存储，并可能导致无穷大

```js
alert(1e500);//Infinity
```

经常会发生精度的损失。

```js
alert( 0.1 + 0.2 == 0.3 ); // false
```

数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。

换句话说，什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。

在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，**在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数**。

==使用二进制数字系统无法 精确 存储 0.1 或 0.2==，就像没有办法将三分之一存储为十进制小数一样。

IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。

我们可以看到：

```js
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

当我们对两个数字进行求和时，它们的“精度损失”会叠加起来。

这就是为什么 0.1 + 0.2 不等于 0.3。

#### toFixed(n)对结果进行舍入

```javascript
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

请注意，`toFixed` 总是返回一个**字符串**。它确保小数点后有 2 位数字。

如果我们有一个电子购物网站，并需要显示 `¥ 0.30`，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字。

#### 乘除法

我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到：

```js
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001	
```

因此，乘除法可以减少误差，但不能完全消除误差。



```javascript
// Hello！我是一个会自我增加的数字！
alert( 9999999999999999 ); // 显示 10000000000000000
```

出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。

JavaScript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。



==数字内部表示的另一个有趣结果是存在两个零：`0` 和 `-0`。==

这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。

在大多数情况下，这种区别并不明显，因为运算符将它们视为相同的值。



### isFinite 和 isNaN

#### isNaN

isNaN(value)将其参数转换为数字，然后测试它是否为NaN。

```js
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```

不能使用===NaN进行比较，因为NaN是独一无二的，它不等于任何东西，包括它自身。

```js
alert( NaN === NaN ); // false
```

##### 与Object.is进行比较

类似于===一样对值进行比较，但他对于两种边缘情况更可靠：

1. 它适用于NaN：Object.is(NaN,NaN)===true
2. 值0和-0是不同的：Object.is(0,-0)===false
3. 在其他所有的情况下：Object.is(a,b)与a===b相同。

==Object.is(val1,val2)YYDS!!==



#### isFinite

isFinite(value)将其参数转换为数字，

==如果是常规数字，返回true，==

==如果是NaN/Infinity/-Infinity 则返回false==

```js
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false，因为是一个特殊的值：NaN
alert( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity
```

有时 isFinite被用于检验字符串值是否为常规数字：

```js
let num = +prompt("Enter a number", '');

// 结果会是 true，除非你输入的是 Infinity、-Infinity 或不是数字
alert( isFinite(num) );
```

**==在所有的数字函数中，包括isFinite，空字符串或仅有空格的字符串均被视为0==**



### parseInt 和 parseFloat

使用加号+或Number()的数字转换是严格的。如果一个值不完全是一个数字，就会失败。

唯一例外的是字符串开头或结尾的空格，它们会被忽略

但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 `"100px"` 或 `"12pt"`。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 `"19€"`，并希望从中提取出一个数值。

这就是 `parseInt` 和 `parseFloat` 的作用。

==**从字符串中读取数字，直至无法读取为止，如果发生error,则返回收集到的数字。**==

parseInt 返回一个整数。

parseFloat 返回一个浮点数。

```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12，只有整数部分被返回了
alert( parseFloat('12.3.4') ); // 12.3，在第二个点出停止了读取
```

某些情况下，`parseInt/parseFloat` 会返回 `NaN`。当没有数字可读时会发生这种情况：

```javascript
alert( parseInt('a123') ); // NaN，第一个符号停止了读取
```

#### parseInt(str,radix)的第二个参数

它指定了数字系统的基数。

因此，parseInt还可以解析十六进制数字/二进制数字等字符串。



### 其他数学函数

#### Math.random()

返回一个从0到1的随机数(不包括1)

#### Math.max（a,b,c…)/Math.min(a,b,c)

从任意数量的参数中返回最大/最小值。

#### Math.pow(n,power)

返回n的给定（power）次幂

### 6.35.toFixed(1)==6.3

在内部，`6.35` 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。

让我们来看看：

```javascript
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
```

精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。

那么 `1.35` 会怎样呢？

```javascript
alert( 1.35.toFixed(20) ); // 1.35000000000000008882
```

在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。**如果我们希望以正确的方式进行舍入，我们应该如何解决 `6.35` 的舍入问题呢？**

在进行舍入前，我们应该使其更接近整数：

```javascript
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
```

请注意，`63.5` 完全没有精度损失。

**这是因为小数部分 `0.5` 实际上是 `1/2`**。

以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：

```javascript
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
```

### 重复，直到输入的是一个数字

创建一个函数 `readNumber`，它提示输入一个数字，直到访问者输入一个有效的数字为止。

结果值必须以数字形式返回。

访问者也可以通过输入空行或点击“取消”来停止该过程。在这种情况下，函数应该返回 `null`。

```js
function readNumber() {
  let num;

  do {
    num = prompt("Enter a number please?", 0);
  } while ( !isFinite(num) );

  if (num === null || num === '') return null;

  return +num;
}

alert(`Read: ${readNumber()}`);
```

## 字符串

字符串的内部格式始终是==UTF-16==，它不依赖于页面编码。

### 引号

#### 反引号

- 反引号允许我们通过${…}将任何表达式嵌入字符串中：

- ==也允许字符串跨行==（单引号和双引号）：

```js
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // 客人清单，多行
```

- 还允许我们在第一个反引号前指定一个“模板函数”。
- 语法是： func\`string`。
  - 函数func被自动调用，接收字符串和嵌入式表达式。
  - 此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。
- 反引号内单引号双引号不需转义字符

### 特殊字符

==可以通过使用“换行符”，以支持使用单引号和双引号来创建跨行字符串==。换行符写作\n，用来表示换行：

```js
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // 一个多行的客人列表
```

| 字符                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| \n                               | 换行                                                         |
| \r                               | 回车                                                         |
| \t                               | 制表符                                                       |
| \xXX                             | 具有给定十六进制Unicode XX的Unicode字符，例如：‘\x7A’和‘z’相同。 |
| \uXXXX                           | 以UTF-16编码的十六进制代码XXX的unicode字符，例如\u00A9 ——是版权符号©的Unicode。它必须正好是4个十六进制数字。 |
| \u{X…XXXXXX}(1到6个十六进制字符) | 具有给定UTF-32编码的unicode符号，一些罕见的字符用两个unicode符号编码，占用4个字节。 这样我们就可以插入长代码了。 |
|                                  |                                                              |

```js
alert( "\u00A9" ); // ©
alert( "\u{20331}" ); // 佫，罕见的中国象形文字（长 unicode）
alert( "\u{1F60D}" ); // 😍，笑脸符号（另一个长 unicode）
```

\ 转义字符

### 字符串长度

length**属性**（不是函数，后面不需括号）表示字符串长度：

alert(\`My\n`.length);//3

==\n是一个单独的字符==

### 访问字符

可以使用方括号，或者调用str.charAt(pos)方法。

第一个字符从0开始。

它们之间的唯一区别，==如果没有找到字符，[]返回undefined，而charAt返回一个空字符串。==

#### for..of遍历字符

```js
for (let char of "Hello") {
  alert(char); // H,e,l,l,o（char 变为 "H"，然后是 "e"，然后是 "l" 等）
}
```

### 字符串是不可变的

在JavaScript中，字符串不可更改。

通常是创建一个新的字符串，并将其分配给str而不是以前的字符串。

```js
let str = 'Hi';

str = 'h' + str[1];  // 替换字符串

alert( str ); // hi
```

### 改变大小写

str.toLowerCase()和toUpperCase()方法可以改变大小写：

或者只将一个字符变成小写：

‘Interface’[0].toLowerCase();

### 查找子字符串

str.indexOf(substr,pos)

从给定位置pos开始，在str中查找substr，如果没有找到，则返回-1，否则返回匹配成功的位置。

indexOf是大小写敏感的

查找全部可以使用循环实现：

```js
let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // 这是我们要查找的目标

let pos = 0;

while(true){
let foundPos = str.indexOf(target,pos);
if(foundPos==-1) break;
alert(`Found at ${foundPos}`);
pos = foundPos+1;
}
//或是简写
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
```

str.lastIndexOf(substr,pos)

从字符串的末尾开始搜索到开头，以相反的顺序列出这些事件。

在if中indexOf有一点不方便。

if(str.indexOf(“Widget”)==!=-1==){

alert(“We found it”);

}

### 按位（bitwise)NOT技巧

bitwise NOT~ 运算符。

它将数字转换为32-bit整数（删除小数部分）对其二进制表示形式中的所有位均取反。

实际上，这意味着一件很简单的事儿：对于32-bit整数，~n等于-（n+1)。

```js
alert( ~2 ); // -3，和 -(2+1) 相同
alert( ~1 ); // -2，和 -(1+1) 相同
alert( ~0 ); // -1，和 -(0+1) 相同
alert( ~-1 ); // 0，和 -(-1+1) 相同
```

**只有n==-1时，~n才为0**

因此，仅当indexOf的结果不是-1时，检查if(~str.indexOf(“…”))才为真。

`if (~str.indexOf(...))` 读作 “if found”。

由于 `~` 运算符将大数字截断为 32 位，因此存在给出 `0` 的其他数字，最小的数字是 `~4294967295=0`。这种检查只有在字符串没有那么长的情况下才是正确的。

### includes , startsWith , endsWith

str.includes(substr,pos)根据str中是否包含substr来返回 true/false。

如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：

```js
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

str.includes的第二个可选参数是开始搜索的起始位置。

**startsWith** & **endsWith**

```js
alert( "Widget".startsWith("Wid") ); // true，"Widget" 以 "Wid" 开始
alert( "Widget".endsWith("get") ); // true，"Widget" 以 "get" 结束
```

### 获取子字符串

#### substring

str.substring(start[,end])

返回字符串在start和end之间的部分。

==**与slice几乎相同，但它允许start大于end。**==

**==但不支持负参数，负参数被视为0。==**

```js
let str = "stringify";

// 这些对于 substring 是相同的
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ……但对 slice 是不同的：
alert( str.slice(2, 6) ); // "ring"（一样）
alert( str.slice(6, 2) ); // ""（空字符串）

```



#### slice

str.slice(start [,end])

返回字符串从 **start** 到 （但不包括） **end** 的部分。

* 如果没有end，会一直运行到字符串末尾。

```js
let str=“stringify”;
alert(str.slice(2));//从第二个位置直到结束
```

* start / end 也有可能是负值。它们的意思是起始位置从字符串结尾计算。

  ```js
  let str = "stringify";
  
  // 从右边的第四个位置开始，在右边的第一个位置结束
  alert( str.slice(-4, -1) ); // 'gif'
  ```

#### substr

str.substr(start[,length])

返回字符串从start开始的给定length的部分。

```js
let str = "stringify";
alert( str.substr(2, 4) ); // 'ring'，从位置 2 开始，获取 4 个字符
```

第一个参数可能是负数，从结尾算起:

```js
let str = "stringify";
alert( str.substr(-4, 2) ); // 'gi'，从第 4 位获取 2 个字符
```

### 总结

| 方法                 | 选择方式                                                | 负值参数        |
| -------------------- | ------------------------------------------------------- | --------------- |
| slice(start,end)     | start~end（不包括end)                                   | 允许            |
| substring(start,end) | start与end之间（包括start,但不包括end),允许start大于end | 负值代表0       |
| substr(start,length) | 从start开始获取长为length的字符串                       | 允许start为负数 |

形式上，`substr` 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的仅浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。

相较于其他两个变体，`slice` 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 `slice` 就足够了。‘’

### 比较字符串

字符串按字母顺序逐字比较。

1. 小写字母总是大于大写字母：

   ```javascript
   alert( 'a' > 'Z' ); // true
   ```

2. 带变音符号的字母存在“乱序”的情况：

   ```javascript
   alert( 'Österreich' > 'Zealand' ); // true
   ```

#### str.codePointAt(pos)

返回在pos位置的字符代码

alert(“Z”.codePointAt(0)); //90

#### String.fromCodePoint(code)

通过数字code创建字符

alert(String.fromCodePoint(90));//Z

也可以使用\u后跟十六进制代码，通过这些代码添加unicode字符

```js
alert(‘\u005a’);//Z
```



- 所有小写字母追随在大写字母之后，因为它们的代码更大。
- 一些像 `Ö` 的字母与主要字母表不同。这里，它的代码比任何从 `a` 到 `z` 的代码都要大。

### 正确的比较

执行字符串比较的“正确”算法比看起来更复杂，因为不同语言的字母都不相同。

因此浏览器需要知道要比较的语言。

幸运的是，所有现代浏览器（==IE10- 需要额外的库 [Intl.JS](https://github.com/andyearnshaw/Intl.js/)==) 都支持国际化标准 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)。

它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。

调用**str.localeCompare(str2)**会根据语言规则返回一个整数

指示字符串str在排序顺序中排在字符串str2的前面，后面，还是相同。

- 如果str排在str2前面，则返回负数。
- 如果str排在str2后面。则返回正数。
- 如果它们在相同位置，则返回0。

```js
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

### 内部，Unicode

#### 代理对

所有常用的字符都是2字节的代码。但2字节只允许65536个组合，这对于每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对2字节的符号编码。

这些符号的长度为2。

```js
alert( '𝒳'.length ); // 2，大写数学符号 X
alert( '😂'.length ); // 2，笑哭表情
alert( '𩷶'.length ); // 2，罕见的中国象形文字
```

代理对在JavaScript被创建的时候并不存在，因此无法被编程语言正确处理。

我们实际上在上面的每个字符串中都有一个符号，但length显示长度为2。

String.fromCodePoint 和 str.codePointAt 是几种处理代理对的少数方法。

它们最近才出现在编程语言中。

在它们之前，只有 [String.fromCharCode](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) 和 [str.charCodeAt](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)。这些方法实际上与 fromCodePoint/codePointAt 相同，但是不适用于代理对。

获取符号可能会非常麻烦，因为代理对被认为是两个字符：

```javascript
alert( '𝒳'[0] ); // 奇怪的符号……
alert( '𝒳'[1] ); // ……代理对的一块
```

技术角度来说，代理对也是可以通过它们的代码检测到的：

如果一个字符的代码在 `0xd800..0xdbff` 范围内，那么它是代理对的第一部分。

下一个字符（第二部分）必须在 `0xdc00..0xdfff` 范围中。

这些范围是按照标准专门为代理对保留的。

### 变音符号和规范化

一些由基本字符组成的符号，在其上方/下方有一个标记。

例如，字母 `a` 可以是 `àáâäãåā` 的基本字符。最常见的“复合”字符在 UTF-16 表中都有自己的代码。但不是全部，因为可能的组合太多。

为了支持任意组合，UTF-16 允许我们使用多个 unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。

例如，如果我们 `S` 后跟有特殊的 “dot above” 字符（代码 `\u0307`），则显示 Ṡ。

例如，如果我们追加一个字符 “dot below”（代码 `\u0323`），那么我们将得到“S 上面和下面都有点”的字符：`Ṩ`。

这在提供良好灵活性的同时，也存在一个有趣的问题：**两个视觉上看起来相同的字符，可以用不同的 unicode 组合表示。**

为了解决这个问题，有一个 “unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。

它由==str.normalize()==实现。

```javascript
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

alert( "S\u0307\u0323".normalize().length ); // 1
alert( "S\u0307\u0323".normalize() == "\u1e68" ); // true
```

有趣的是，在实际情况下，`normalize()` 实际上将一个由 3 个字符组成的序列合并为一个：`\u1e68`（S 有两个点）。

事实上，情况并非总是如此，==因为符号 `Ṩ` 是“常用”的，所以 UTF-16 创建者把它包含在主表中==并给它了对应的代码。

### 首字母大写

我们不能“替换”第一个字符，因为在 JavaScript 中字符串是不可变的。

但是我们可以根据已有字符串创建一个首字母大写的新字符串：

```javascript
let newStr = str[0].toUpperCase() + str.slice(1);
```

这里存在一个小问题。如果 `str` 是空的，那么 `str[0]` 就是 `undefined`，但由于 `undefined` 并没有 `toUpperCase()` 方法，因此我们会得到一个错误。

存在如下两种变体：

1. 使用 `str.charAt(0)`，因为它总是会返回一个字符串（可能为空）。
2. 为空字符添加测试。

这是第二种变体：

```javascript
function ucFirst(str) {
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("john") ); // John
```



## 数组

对象允许存储键值集合。

但很多时候我们需要有序集合，里面的元素都是按顺序排列的。

比如用户，商品，以及HTML元素。

对象不能提供能够管理元素顺序的方法。我们不能再已有的元素“之间”插入一个新的属性。

而数组可以存储有序的集合。

### 声明

创建一个空数组有两种语法。

let arr = new Array();

let arr = [];

length属性的值是数组中元素的总个数。

arr.length();

alert(arr)显示整个数组

数组可以存储任何类型的元素。

```js
// 混合值
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// 获取索引为 1 的对象然后显示它的 name
alert( arr[1].name ); // John

// 获取索引为 3 的函数并执行
arr[3](); // hello
```

### pop/push,shift/unshift 方法

queue是最常见的使用数组的方法之一。

- push在末端添加一个元素
- shift取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。

数组还有另一个用例，就是数据结构 栈。

它支持两种操作：

- push 在末端添加一个元素。
- pop 从末端取出一个元素。

JavaScript中的数组既可以用作队列，也可以用作栈，它们允许你从首端/末端来添加/删除元素。

这样的数据结构称为双端队列(deque)。

#### 作用于数组末端的方法

pop 取出并返回数组的最后一个元素

push 在数组末端添加元素

==调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。==

#### 作用于数组首端的方法

shift 取出数组的第一个元素并返回它

unshift 在数组的首端添加元素

push 和 unshift 方法都可以一次添加多个元素。

```js
let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
```



### 内部

==**数组是一种特殊的对象。**==

使用方括号来访问属性 arr[0]实际上是来自于对象的语法。

它其实与obj[key]相同，其中，arr是对象，而数字用作键。

它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及length属性。但从本质上讲，它仍然是一个对象。

通过引用进行复制:

```javascript
let fruits = ["Banana"]

let arr = fruits; // 通过引用复制 (两个变量引用的是相同的数组)

alert( arr === fruits ); // true

arr.push("Pear"); // 通过引用修改数组

alert( fruits ); // Banana, Pear — 现在有 2 项了
```

数组的内部实现：JavaScript引擎尝试把这些元素一个接一个地存储在连续的内存区域。而且还有一些其他的优化，使数组运行得非常快。

但是如果不像有序集合那样使用数组，而是像常规对象那样，这些优化就不生效了。

数组误用的几种方式：

- 添加一个非数字的属性，比如arr.test = 5。
- 制造空洞，比如，添加arr[0],然后添加arr[1000]（它们中间什么都没有）
- 以倒序填充数组。比如arr[1000],arr[999]等等。

请将数组视为作用于**==有序数据==**的特殊结构。

### 性能

push/pop方法运行的比较快，而shift/unshift比较慢。

为什么作用于数组的末端会比首端快呢？

shift()只获取并移除数字0对应的元素是不够的，其它元素也需要被重新编号。

shift操作必须做三件事。

- 移除索引为0的元素。
- 把所有的元素向左移动
- 更新length属性

数组里的元素越多，移动需要花越多的时间，也就意味着越多的内存操作。

pop方法不需要移动任何东西，其他元素都保留了各自的索引。

### 循环

遍历数组的古老方式是for循环。

```js
let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
```

但对于数组来说还有另一种循环方式，for…of

```js
let fruits = [“Apple”,“Orange”，“Plum”];

for(let fruit of fruits){
alert(fruit);
}
```

for..of==不能获取当前元素的索引，只是获取元素值==。

因为数组也是对象，所以使用for..in也是可以的。

```js
for(let key in arr){
	alert( arr[key]);// Apple, Orange, Pear
}
```

但这其实是一个很不好的想法。会有一些潜在问题存在：

1. for..in 循环会遍历所有属性，不仅仅是这些数字属性。
   1. 在浏览器和其它环境中有一种称为“类数组”的对象，它们看似是数组。它们有length 和索引属性，但是也可能有其它的非数字的属性和方法，通常是我们不需要的。
2. for..in 循环适用于普通对象，并且做了对应的优化。但是不使于数组，因此速度要慢10-100倍，虽然依然很快，但是遇到瓶颈时可能会有问题。

**通常来说，不应该使用 for .. in来处理数组**



### 关于“length”

当我们修改数组的时候，length 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值+1。

例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 `length` 也会很大：

```javascript
let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
```

length属性是可写的，如果我们手动增加它，则不会发生任何有趣的事儿，如果减少它，数组就会被截断，该过程是不可逆的。

清空数组最简单的方法就是：arr.length=0。



### new Array()

这是创建数组的另一种语法：

let arr= new Array(“Apple”,“Pear”，“etc”);

很少被使用一，因为方括号更短更简洁。而且，这种语法还有一个棘手的特性。

==如果使用单个参数（即数字）调用new Array，那么它会创建一个==

**==指定了长度，却没有任何项的数组==**。

```js
let arr = new Array(2); // 会创建一个 [2] 的数组吗？

alert( arr[0] ); // undefined！没有元素。

alert( arr.length ); // length 2
```

在上面的代码中，new Array（number）创建的数组的所有元素都是undefined。

### 多维数组

数组里的项也可以是数组。可以将其用于多维数组，例如存储矩阵：

let matrix=[

[1,2,3],

[4,5,6],

[7,8,9]];

alert(matrix\[1][1])；//最中间的那个数。

### toString

==**数组有自己的toString方法的实现。**==

会返回以逗号隔开的元素列表。

例如：

```js
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"

**数组没有 Symbol.toPrimitive,也没有 valueOf ，只能执行toString进行转换，**

所以这里

[]变成了一个空字符串

[1]变成“1”。

[1,2]变成了“1,2”。

当“+”运算符把一些项加到字符串的后面时，加号后面的项也会被转换成字符串。

### 不要使用== 比较数组

不应该使用==运算符比较JavaScript中的数组。

该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。

##### ==的规则：

- 仅当两个对象引用的是同一个对象时，它们才相等 `==`。
- 如果 `==` 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 [对象 — 原始值转换](https://zh.javascript.info/object-toprimitive) 一章所述。
- ……`null` 和 `undefined` 相等 `==`，且各自不等于任何其他的值。

所以，如果我们使用 `==` 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。

例如：

```javascript
alert( [] == [] ); // false
alert( [0] == [0] ); // false
```

从技术上讲，这些数组是不同的对象。所以它们不相等。`==` 运算符不会进行逐项比较。

与原始类型的比较也可能会产生看似很奇怪的结果：

```javascript
alert( 0 == [] ); // true

alert('0' == [] ); // false
```

在这里的两个例子中，我们将原始类型和数组对象进行比较。因此，数组 `[]` 被转换为原始类型以进行比较，被转换成了一个空字符串 `''`。

然后，接下来的比较就是原始类型之间的比较，如 [类型转换](https://zh.javascript.info/type-conversions) 一章所述：

```javascript
// 在 [] 被转换为 '' 后
alert( 0 == '' ); // true，因为 '' 被转换成了数字 0

alert('0' == '' ); // false，没有进一步的类型转换，是不同的字符串
```

### 在数组上下文调用

```javascript
let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){...}
```

`arr[2]()` 调用从句法来看可以类比于==obj\[method]()==，与 `obj` 对应的是 `arr`，与 `method` 对应的是 `2`。

所以调用 `arr[2]` 函数也就是调用对象函数。自然地，它接收 `this` 引用的对象 `arr` 然后输出该数组：

该数组有 3 项：最开始有两个，后来添加进来一个函数。

### 输入数字求和

写出函数 `sumInput()`，要求如下：

- 使用 `prompt` 向用户索要值，并存在数组中。
- 当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。
- 计算并返回数组所有项之和。

P.S. `0` 是有效的数字，不要因为是 0 就停止问询。

请注意这个解决方案的细微但是很重要的细节。我们没有在 `prompt` 后立即把 `value` 转换成数字，因为在执行 `value = +value` 之后，就没办法区分出空字符串（中断标志）和数字 0（合法输入）了，所以要放到后面再处理。

```javascript
function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("A number please?", 0);

    // 应该结束了吗？
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
```

## 数组方法

### 添加/移除数组元素

arr.push()

arr.pop()

arr.shift()

arr.unshift()



#### 删除数组元素

数组的对象方法 delete

```js
let arr = ["I", "go", "home"];

delete arr[1]; // remove "go"

alert( arr[1] ); // undefined

// now arr = ["I",  , "home"];
alert( arr.length ); // 3
```

对应项被删除了。

因为delete obj.key是通过key来移除对应的值。

#### arr.splice()

arr.splice()可以添加/删除/插入元素。

arr.splice(start[, deleteCount, elem1, ..., elemN])

从索引start开始修改arr：删除deleteCount个元素并在当前位置插入elem1，…，elemN,

==返回已删除元素的数组。==

**删除:**

```js
let arr = ["I", "study", "JavaScript"];

arr.splice(1, 1); // 从索引 1 开始删除 1 个元素

alert( arr ); // ["I", "JavaScript"]
```

**删除与替换：**

```js
let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // now ["Let's", "dance", "right", "now"]
```

**替换：**

我们可以将 deleteCount 设置为 0，splice 方法就能够插入元素而不用删除任何元素：

```js
let arr = ["I", "study", "JavaScript"];

// 从索引 2 开始
// 删除 0 个元素
// 然后插入 "complex" 和 "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

**允许负向索引**

```js
let arr = [1, 2, 5];

// 从索引 -1（尾端前一位）
// 删除 0 个元素，
// 然后插入 3 和 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```

### arr.slice()

arr.slice([start],[end])

```js
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）

alert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）
```

==会返回一个新数组==，将所有从索引 `start` 到 `end`（不包括 `end`）的数组项复制到一个新的数组。`start` 和 `end` 都可以是负数，在这种情况下，从末尾计算索引。

不带参数调用，会创建一个arr的副本，以进行不影响原始数组的进一步转换。

### arr.concat()

创建一个新数组，其中包含来自于其他数组和其他项的值。

arr.concat(arg1, arg2...)

它接受任意数量的参数 —— 数组或值都可以。

结果是一个包含==来自于 `arr`，然后是 `arg1`，`arg2` 的元素的新数组。==

```js
let arr = [1, 2];

// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

只对数组中的元素逐个添加，其他对象，即使看起来像数组，仍然会作为一个整体添加。

```js
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

如果类似数组的对象具有==**Symbol.isConcatSpreadable**==属性，会被concat当作一个数组来处理。

```js
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

### 遍历：arr.forEach()

允许为数组的每个元素都运行一个函数。

==函数的返回结果会被抛弃和忽略。==

语法：

```js
arr.forEach(function(item,index,array)){
	
}
```

显示数组的每个元素：

```js
// 对每个元素调用 alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

显示在目标数组中的位置：

```js
["Bilbo","Gandalf","Nazgul"].forEach((item,index,array)=>{
alert(`${item} is at index ${index} in ${array}`);
})
```



### 在数组中搜索

#### indexOf/lastIndexOf/includes

- `arr.indexOf(item, from)` 从索引 `from` 开始搜索 `item`，如果找到则返回索引，否则返回 `-1`。
- `arr.lastIndexOf(item, from)` —— 和上面相同，只是从右向左搜索。
- `arr.includes(item, from)` —— 从索引 `from` 开始搜索 `item`，如果找到则返回 `true`（译注：如果没找到，则返回 `false`）。



```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

==**使用的是严格相等 \=\== 比较**==，所以如果搜索false，会精确到false,而不是数字0。

##### includes可以正确处理NaN

严格相等对于NaN无效。

```js
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1（应该为 0，但是严格相等 === equality 对 NaN 无效）
alert( arr.includes(NaN) );// true（这个结果是对的）
```



### find/findIndex

```js
let result = arr.find(function(item, index, array) {
  
});
```

依次对数组中的每个元素调用该函数：

item 是元素。
index 是它的索引。
array 是数组本身。

如果返回 true，则返回 item 并停止迭代
对于假值（falsy）的情况，则返回 undefined

```js
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

find返回元素本身，找不到返回undefined，findIndex返回索引，未找到返回-1。

### filter

find 方法搜索使函数返回true的第一个元素。

如果如果需要匹配的有很多，可以使用arr.filter(fn)

语法与find大致相同，但是filter返回的是所有匹配元素组成的数组。

```js
let results = arr.filter(function(item, index, array) {
  // 如果 true item 被 push 到 results，迭代继续
  // 如果什么都没找到，则返回空数组
});
```

```js
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// 返回前两个用户的数组
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```



### 转换数组

#### map

对数组的每个元素都调用函数，并==**返回结果数组**==

语法：

```js
let result = arr.map(function(item,index,array)){}
```

将每个元素转换为它的字符串长度：

```js
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

#### sort(fn)

对数组进行 原位排序（in-place) 更改元素的顺序，对原数组进行操作，不生成新数组。

==**返回排序后的数组，但返回值通常会被忽略，因为修改了arr本身。**==

```js
let arr = [ 1, 2, 15 ];

// 该方法重新排列 arr 的内容
arr.sort();

alert( arr );  // 1, 15, 2
```

==**元素在默认情况下按字符串进行排序**==

要使用自定义的排序顺序，需要提供一个函数作为arr.sort()的参数。

```js
function compare(a,b){
if(a>b) return 1;
if(a==b) return 0;
if(a<b) return -1；
}
arr.sort(compare);
```

?

```javascript
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。

?

##### 比较函数可以返回任何数字

返回正数表示> 负数表示<

```js
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```

使用箭头函数

```js
arr.sort( (a, b) => a - b );
```

使用localeCompare for strings

对于许多字母，最好使用 `str.localeCompare` 方法正确地对字母进行排序，例如 `Ö`。

例如，让我们用德语对几个国家/地区进行排序：

```javascript
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich（错的）

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam（对的！）
```

==countries.sort( (a, b) => a.localeCompare(b) )==

#### reverse

用于颠倒arr中元素的顺序

```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

#### split / join

将有分隔符的字符串转换为数组：

str.split(delim) 通过给定的分隔符将字符串分割成一个数组。

```js
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo（和其他名字）
}
```

**split有第二个可选的数字参数，对数组长度的限制**，如果提供了，那么额外的元素会被忽略。

##### 拆分为字母

调用带有空参数s的split(s)，会将字符串拆分为字母数组：

```js
let str = "test";

alert( str.split('') ); // t,e,s,t
```

#### join(glue)

```js
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 使用分号 ; 将数组粘合成字符串

alert( str ); // Bilbo;Gandalf;Nazgul
```

### 遍历数组与累加计算：reduce/reduceRight

当我们需要遍历一个数组时，我们可以使用

forEach,for 或 for..of

当需要遍历并返回每个元素的数据时，可以使用map

reduce/reduceRight用于根据数组计算单个值。

```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。

参数：

accumulator —— 是上一个函数调用的结果，第一次等于 initial（如果提供了 initial 的话）

==**如果不提供则为数组第一个元素的值，并从第二个元素开始迭代**==。

==**如果数组为空，那么在没有初始值的情况下调用reduce会导致错误。**==

item —— 当前的数组元素。
index —— 当前索引。
arr —— 数组本身。

```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

1. 在第一次运行时，`sum` 的值为初始值 `initial`（`reduce` 的最后一个参数），等于 0，`current` 是第一个数组元素，等于 `1`。所以函数运行的结果是 `1`。
2. 在第二次运行时，`sum = 1`，我们将第二个数组元素（`2`）与其相加并返回。
3. 在第三次运行中，`sum = 3`，我们继续把下一个元素与其相加，以此类推……

### 判断是否为数组 Array.isArray

数组是基于对象的，不构成单独的语言类型。

所以 typeof 不能帮助从数组中区分出普通对象。

Array.isArray(value)：如果 `value` 是一个数组，则返回 `true`；否则返回 `false`。

```javascript
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

### 😵大多数方法都支持 thisArg

几乎所有调用函数的数组方法，比如 find / filter / map，

==除了sort==是一个特例，都接受一个可选的附加参数 thisArg。

thisArg 参数的值在 func 中变为 this。

例如使用army对象方法作为过滤器，thisArg用于传递上下文

```js
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// 找到 army.canJoin 返回 true 的 user
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

==**如果在上面的示例中我们使用了 users.filter(army.canJoin)，那么 army.canJoin 将被作为独立函数调用，并且这时 this=undefined，从而会导致即时错误。**==

可以用users.filter(user=>army.canJoin(user))替代。

### 总结

#### 添加/删除元素

push/pop

unshift/shift

※splice(pos,deleteCount,..items) 从 pos 开始删除 deleteCount 个元素，并插入 items 。

slice（start ,end) 创建一个新数组，将从索引star到end（不包括end)的元素复制进去。

concat (..items)返回一个新数组，复制当前数组的所有元素，并向其中添加items。如果items中的任意一项是一个数组，那么就取其元素。

#### 搜索元素

indexOf/lastIndexOf（item，pos） 

- 从索引pos开始搜索item,使用绝对相等===，不能正确处理NaN
- 找到返回元素索引，找不到返回-1

includes(value) 根据数组是否有value，返回true/false

find/filter(func) 通过func过滤元素，返回使func返回true的一个元素值/所有元素值

findIndex(func) 返回元素的索引

#### 遍历元素

forEach(func)   对每个元素都调用func 不返回任何内容

#### 转换数组

map(func) 根据对每个元素调用func的结果创建一个新数组。

※sort(func) 对数组进行原位排序，然后返回它。

※reverse() 原位翻转数组，然后返回它。

split / join 将字符串转换为数组/将数组转换为字符串 并返回。

reduce/reduceRight(func,initial)  通过对每个元素调用func计算累加值，并在调用之间传递中间结果。

#### 检查数组

Array.isArray(arr) 检查arr是否为一个数组。

**==splice / sort /reverse 修改的是数组本身。==**



#### arr.some(fn)/arr.every(fn)

与map类似，对数组的每个元素调用函数fn，

如果fn返回一个真值，arr.some()立即返回true并停止迭代其余数组项。

如果fn返回一个假值，arr.every()立即返回false并停止迭代。

##### 数组的比较

因为数组本质上是对象，因此，只有我们用==比较的是两个引用同一数组的变量，否则它们永远不相等。

我们可以使用 `every` 来比较数组：

```javascript
function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
```

#### arr.fill(value,start,end)

从索引start到end，用重复的value填充数组。

#### arr.copyWithin (target,start,end) 

将从位置start到end的所有元素复制到自身的target位置（覆盖现有元素）。

#### arr.flat(depth)/arr.flatMap(fn)

从多维数组创建一个新的扁平数组。

#### Array.of(element0[,element1[,…[,elementN]]])

基于可变数量的参数创建一个新的Array实例，而不需要考虑参数的数量或类型。

### 原位（in place）过滤范围

写一个函数 `filterRangeInPlace(arr, a, b)`，该函数获取一个数组 `arr`，并删除其中介于 `a` 和 `b` 区间以外的所有值。检查：`a ≤ arr[i] ≤ b`。

该函数应该只修改数组。它不应该返回任何东西。

```js
function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // 如果超出范围，则删除
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}
```

### 降序排序

```js
let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );	
```

### 复制和排序数组

我们有一个字符串数组 `arr`。我们希望有一个排序过的副本，但保持 `arr` 不变。

创建一个函数 `copySorted(arr)` 返回这样一个副本。

==slice创建一个副本==

```js
function copySorted(arr) {
  return arr.slice().sort();
}

```

### 创建一个可扩展的 calculator

创建一个构造函数 `Calculator`，以创建“可扩展”的 calculator 对象。

该任务由两部分组成。

1. 首先，实现 `calculate(str)` 方法，该方法接受像 `"1 + 2"` 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 `+` 和减号 `-`。

   用法示例：

   ```javascript
   let calc = new Calculator;
   
   alert( calc.calculate("3 + 7") ); // 10
   ```

2. 然后添加方法 `addMethod(name, func)`，该方法教 calculator 进行新操作。它需要运算符 `name` 和实现它的双参数函数 `func(a,b)`。

   例如，我们添加乘法 `*`，除法 `/` 和求幂 `**`：

   ```javascript
   let powerCalc = new Calculator;
   powerCalc.addMethod("*", (a, b) => a * b);
   powerCalc.addMethod("/", (a, b) => a / b);
   powerCalc.addMethod("**", (a, b) => a ** b);
   
   let result = powerCalc.calculate("2 ** 3");
   alert( result ); // 8
   ```

- 此任务中没有括号或复杂的表达式。
- 数字和运算符之间只有一个空格。
- 你可以自行选择是否添加错误处理功能。

- 请注意方法的存储方式。它们只是被添加到 `this.methods` 属性中。
- 所有检测和数字转换都通过 `calculate` 方法完成。将来可能会扩展它以支持更复杂的表达式。

```javascript
function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
```

### 箭头函数返回对象

有两种箭头函数的写法：直接返回值 `value => expr` 和带主体的 `value => {...}`。

JavaScript 在这里会把 `{` 视为函数体的开始，而不是对象的开始。解决方法是将它们包装在普通括号 `()` 中：

```javascript
let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
```

升序排列的函数可以简写为：`(a, b) => a.age - b.age`。

### 随机排列数组

编写函数 `shuffle(array)` 来随机排列数组的元素。

多次运行 `shuffle` 可能导致元素顺序的不同。例如：

```javascript
let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
```

所有元素顺序应该具有相等的概率。例如，可以将 `[1,2,3]` 重新排序为 `[1,2,3]` 或 `[1,3,2]` 或 `[3,1,2]` 等，每种情况的概率相等。

解决方案

简单的解决方案可以是：

```javascript
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
```

这样是可以的，因为 `Math.random() - 0.5` 是一个可能是正数或负数的随机数，因此排序函数会随机地对数组中的元素进行重新排序。

但是，由于排序函数并非旨在以这种方式使用，因此并非所有的排列都具有相同的概率。

例如，请考虑下面的代码。它运行 100 万次 `shuffle` 并计算所有可能结果的出现次数：

```javascript
function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// 所有可能排列的出现次数
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// 显示所有可能排列的出现次数
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
```

示例结果（取决于 Javascript 引擎）：

```javascript
123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
```

我们可以清楚地看到这种倾斜：`123` 和 `213` 的出现频率比其他情况高得多。

使用不同的 JavaScript 引擎运行这个示例代码得到的结果可能会有所不同，但是我们已经可以看到这种方法是不可靠的。

为什么它不起作用？一般来说，`sort` 是一个“黑匣子”：我们将一个数组和一个比较函数放入其中，并期望其对数组进行排序。但是由于比较的完全随机性，这个黑匣子疯了，它发疯地确切程度取决于引擎中的具体实现方法。

还有其他很好的方法可以完成这项任务。例如，有一个很棒的算法叫作 [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle)。其思路是：

==**逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置：**==

```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // 从 0 到 i 的随机索引

    // 交换元素 array[i] 和 array[j]
    // 我们使用“解构分配（destructuring assignment）”语法来实现它
    // 你将在后面的章节中找到有关该语法的更多详细信息
    // 可以写成：
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
```

让我们以相同的方式测试一下：

```javascript
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// 所有可能排列的出现次数
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// 显示所有可能排列的出现次数
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
```

示例输出：

```javascript
123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
```

现在看起来不错：所有排列都以相同的概率出现。

另外，在性能方面，Fisher — Yates 算法要好得多，没有“排序”开销。

### 数组去重

`arr` 是一个数组。

创建一个函数 `unique(arr)`，返回去除重复元素后的数组 `arr`。

例如：

```javascript
function unique(arr) {
  /* your code */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
```

解决方案

让我们先遍历数字：

- 对于每个元素，我们将检查结果数组是否已经有该元素。
- 如果有，则忽略，否则将其添加到结果中。

```javascript
function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
```

代码有效，但其中存在潜在的性能问题。

方法 `result.includes(str)` 在内部遍历数组 `result`，并将每个元素与 `str` 进行比较以找到匹配项。

所以如果 `result` 中有 `100` 个元素，并且没有任何一项与 `str` 匹配，那么它将遍历整个 `result` 并进行 `100` 次比较。如果 `result` 很大，比如 `10000`，那么就会有 `10000` 次的比较。

这本身并不是问题，因为 JavaScript 引擎速度非常快，所以遍历一个有 `10000` 个元素的数组只需要几微秒。

但是我们在 `for`循环中对 `arr` 的每个元素都进行了一次检测。

因此，如果 `arr.length` 是 `10000`，我们会有 `10000 * 10000` = 1 亿次的比较。那真的太多了。

所以该解决方案仅适用于小型数组。

### 😲从数组创建键（值）对象

假设我们收到了一个用户数组，形式为：`{id:..., name:..., age... }`。

创建一个函数 `groupById(arr)` 从该数组创建对象，以 `id` 为键（key），数组项为值。

例如:

```javascript
let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// 调用函数后，我们应该得到：

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
```

处理服务端数据时，这个函数很有用。

在这个任务里我们假设 `id` 是唯一的。没有两个具有相同 `id` 的数组项。

```javascript
function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}
```

## Iterable object (可迭代对象)

可迭代 (Iterable) 对象是数组的泛化。这个概念是说

==**任何对象都可以被定制为可在for..of循环中使用的对象。**==

**可以应用 for..of 的对象被称为可迭代的。**

数组是可迭代的。

但不仅仅是数组，很多其他内建对象也都是可迭代的。

例如字符串也是可迭代的。

### Symbol.iterator

例如，我们有一个range对象，代表了一个数字区间，看上去很适合使用for..of循环。

```js
let range={
from:1,
to:5
};

// 我们希望 for..of 这样运行：
//for（let num of range) num=1,2,3,4,5
```

为了让对象可迭代（即让for..of可以运行） 我们需要为对象添加一个名为Symbol.iterator的方法(一个专门用于使对象可迭代的内置symbol)。

1.当for..of循环启动时，它会调用这个方法（如果没找到，就会报错）。**==这个方法必须返回一个迭代器（iterator）——一个有next方法的对象。==**

2.从此开始，==**for..of仅适用于这个被返回的对象。**==

3.当for..of循环希望取得下一个数值，它就调用这个对象的next()方法。

4.next()方法返回的结果的格式必须是**{done:Boolean,value:any}**，

当done==true时，表示迭代结束，

否则 value是下一个值。

```js
let range = {
from:1,
to:5
};
// 1. for..of 调用首先会调用这个：
range[Symbol.iterator] = function(){

//..它返回迭代器对象（iterator object)
//2.接下来，for..of仅与此迭代器一起工作，要求它提供下一个值
return{
 current:this.from,
 last:this.to,
    //3.next() 在 for..of 的每一轮循环迭代中被调用
    next(){
        //4.它将会返回{done:..，value:...}格式的对象
        if(this.current <= this.last){
            return {
                done:false,
                value:this.current++
            };}
        else{
            return { done:true };
        }
        }
    }
}
}
for (let num of range) {
  alert(num); // 1, 然后是 2, 3, 4, 5
}
```

可迭代对象本身没有next()方法

相反，是通过调用range\[Symbol.iterator]()创建了另一个对象，即所谓的“迭代器”对象，并且它的next会为迭代生成值。

因此，迭代器对象 和与其 进行迭代的对象 是分开的。

从技术上说，我们可以将它们合并，并使用range自身作为迭代器来简化代码。

```js
let range={
from:1,
to:5,

[Symbol.iterator](){
this.current=this.from;
return this;
},
next()
{
if(this.current<=this.to){
return{
done:false,
value:this.current++
};
}else{
return {done:true};
}
}
}
};

for(let num of range)
{alert(num);}//1,2,3,4,5

```

现在range[Symbol.iterator]返回的是range对象自身：它包括了必需的next()方法，并通过this.current记忆了当前的迭代进程。

**但缺点是：**

现在不可能同时在对象上运行两个 for..of循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的for..of是很罕见的，即使在异步情况下。

#### 无穷迭代器（iterator)

是可能的，例如将range设置为 range.to=Infinity,这时range则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。

next没有什么限制，他可以返回越来越多的值，这是正常的。

当然，迭代这种对象的for..of循环将不会停止，但是我们可以通过使用break来停止它。



### 字符串是可迭代的

==**数组和字符串是使用最广泛的内建可迭代对象。**==

对于一个字符串，for..of遍历它的每个字符。

for(let char of “test”){

​	alert(char);

}

**对于代理对（surrogate pairs)，即UTF-16的扩展字符 , 它也能正常工作。**

### 显式调用迭代器

我们将会采用与for..of完全相同的方式遍历字符串，但使用的是直接调用。这段代码创建了一个字符串迭代器，并“手动”从中获取值。

let str=“Hello”;

let iterator = str \[Symbol.iterator]();

while(true)

{

let result=iterator.next();

if(result.done) break;

alert(result.value);

}

很少需要我们这样做，但是比for..of给了我们更多的控制权，例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。

### 可迭代（iterable）和类数组（array-like）

Iterable 是==实现了Symbol.iterator方法的对象==。

Array-like 是==有索引和length 属性的对象==，所以它们看起来很像数组。

字符串即是可迭代的（for..of对它们有效），又是类数组的（它们有数值索引和length属性），但是一个可迭代对象也许不是类数组对象。反之亦然。



可迭代对象和类数组对象通常都不是数组。

它们没有数组的方法，如push,pop，

如何使用数组方法操作range?

### Array.from

有一个全局方法Array.from可以接受

==**一个可迭代或类数组的值，**==

并从中获取一个真正的数组，然后我们就可以对其调用数组方法了。

```js
let arrayLike={
	0:"Hello",
	1:"World",
	length:2
};
let arr = Array.from(arrayLike);//(*)
alert(arr.pop()); //World
```

在(*)行的Array.from方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素复制到这个新数组。

如果是可迭代对象，也是同样：

```js
let arr = Array.from(range);
alert(arr);//1,2,3,4,5 数组的toString转化方法生效
```

Array.from 的完整语法允许我们提供一个可选的“映射”（mapping）函数：

Array.from(obj[,mapFn,thisArg])

可选的第二个参数mapFn 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外thisArg允许我们为该函数设置this。

```js
let arr = Array.from(range,num => num * num);
alert(Arr);//1,4,9,16,25
```

用Array.from将一个字符串转换为单个字符的数组：

```js
let str = '𝒳😂';

// 将 str 拆分为字符数组
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```

与 str.split方法不同，==它依赖于字符串的可迭代特性==。

**因此，就像for..of一样，可以正确地处理代理对。**

技术上来讲，它和下面这段代码做的是相同的事：

```javascript
let str = '𝒳😂';

let chars = []; // Array.from 内部执行相同的循环
for (let char of str) {
  chars.push(char);
}

alert(chars);
```

但Array.from精简很多。

#### **我们甚至可以基于Array.from创建代理感知（surrogate-aware)的slice方法**

（即能处理UTF-16扩展字符的slice方法）：

原生slice不支持识别代理对。

```js
function slice(str,start,end){
return  Array.from(str).slice(start,end).join(‘’);
}
let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）
alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）
```

### 总结

可以应用for..of的对象被称为可迭代的。

技术上来说，可迭代对象必须实现Symbol.iterator方法。

- obj\[Symbol.iterator]()的结果被称为 迭代器（iterator） 由它处理进一步的迭代过程。
- 一个迭代器必须有next()方法，它返回一个{done:Boolean ,value:any}对象，这里 done:true 表明迭代结束，否则value就是下一个值。
- Symbol.iterator方法会被for..of自动调用，我们也可以直接调用它。
- 内置的可迭代对象例如字符串和数组，都实现了Symbol.iterator。
- 字符串迭代器(for..of)能够识别代理对（surrogate pair）。但字符串的slice方法不可以。可以通过Array.from(str).slice（start,end).join(‘’)来实现识别代理对的slice方法。

有索引属性和length属性的对象被称为类数组对象。

这种对象可能还具有其他属性和方法，但是没有数组的内建方法。

`Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 `obj` 转化为真正的数组 `Array`，然后我们就可以对它应用数组的方法。可选参数 `mapFn` 和 `thisArg` 允许我们将函数应用到每个元素。

## Map and Set（映射和集合）

### Map

Map是一个带键的数据项的集合，就像一个Object 一样。但是它们最大的差别是Map允许任何类型的键（key）。

它的方法和属性如下：

- new Map() ——创建map。
- map.set(key,value) 根据键存储值。
- map.get(key) 根据键来返回值，如果map中不存在对应的key,则返回undefined。
- map.has(key) 如果key存在则返回true，否则返回false
- map.delete(key)——删除指定键的值。
- map.clear() 清空map
- map.size 返回当前的元素个数

普通的 Object 会将键转化为字符串,而Map不会。

```js
let map = new Map();

map.set('1','str1');//字符串键
map.set(1,'num1');//数字键
map.set(true,'bool1');//布尔值键

// 还记得普通的 Object 吗? 它会将键转化为字符串
// Map 则会保留键的类型，所以下面这两个结果不同：
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```

如我们所见，与对象不同，键不会被转换为字符串，可以是任何类型。

#### map[key]不是使用Map的正确方式

虽然map[key]也有效，例如我们可以设置map[key]=2，这样会将map视为JavaScript的plain object，因此它存在相应的限制，==如没有对象键等。==

所以我们应该使用map方法：set 和 get等。

#### Map还可以使用对象作为键。

```js
let john ={name:"John"}；

let visitsCountMap = new Map();
//john是Map中的键
visitsCountMap.set(john,123);
alert(visitsCountMap.get(john));//123
```

使用对象作为键是Map最值得注意和最重要的功能之一。

```js
let john = { name: "John" };

let visitsCountObj = {}; // 尝试使用对象

visitsCountObj[john] = 123; // 尝试将 john 对象作为键

// 是写成了这样!
alert( visitsCountObj["[object Object]"] ); // 123
```

因为visitsCountObj是一个plain Object，它会将所有的键如john转换为字符串，所以我们得到字符串键“[object object]”。==对象转换为字符串后的结果==

#### Map是怎么比较键的？

Map使用SameValueZero算法来比较键是否相等，和严格等于===差不多，但区别是

**NaN被看成等于NaN**

所以NaN也可以被用作键。

这个算法不能被改变或者自定义。

#### 链式调用

==**每一次map.set 调用都返回map本身，**==

所以可以进行链式调用。

```js
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```

### Map 迭代

如果要在map里使用循环，可以使用以下三个方法：

- map.key() 遍历并返回所有的键，
- map.values( ) 遍历并返回所有的值
- map.entries() 遍历并返回所有的实体[key,value]，for..of在默认情况下使用的就是这个。

```js
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 遍历所有的键（vegetables）
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 遍历所有的值（amounts）
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// 遍历所有的实体 [key, value]
for (let entry of recipeMap) { // 与 recipeMap.entries() 相同
  alert(entry); // cucumber,500 (and so on)
}
```

#### 使用插入顺序

迭代的顺序与插入值的顺序相同，与普通的Object不同，Map保留了此顺序。

> 对象中的整数属性会按顺序排列，其他的按照插入顺序。

Map有内置的forEach方法，与Array类似：

```js
// 对每个键值对 (key, value) 运行 forEach 函数
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
```

### Object.entries:从对象创建Map

当创建Map后，我们可以传入一个==**带有键值对的数组**==（或其他**可迭代对象**）来进行初始化，如下所示：

```js
// 键值对 [key, value] 数组
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
```

如果我们想从一个已有的普通对象（plain object）来创建一个Map，那么我们可以使用内建方法Object.entries(obj)，该方法返回对象的键/值对数组，该数组格式完全按照Map所需的格式。

```js
let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
```

这里 Object.entries 返回 键/值对数组：[[“name”,“John”]，[“age”,30]]。

这就是Map所需要的格式。

**Object.fromEntries方法的作用是相反的**：

给定一个具有[key,value]键值对的数组，它会根据给定数组创建一个对象：

```js
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// 现在 prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

**我们可以使用Object.fromEntries从Map得到一个普通对象(plain object)。**

例如，我们在Map中存储了一些数据，但是我们需要把这些数据传给普通对象的第三方代码。

```js
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)

// 完成了！
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

**调用map.entries()返回了一个可迭代的键值对，**

这刚好是Object.fromEntries所需要的格式。

可以把带(*)这一行写得更短：

let obj = Object.fromEntries(map);

上面的代码作用也是一样的，因为

==**Object.fromEntries 期望得到一个可迭代对象作为参数，而不一定是数组。**==

**并且 `map` 的标准迭代会返回跟 `map.entries()` 一样的键/值对。**

因此，我们可以获得一个普通对象（plain object），其键/值对与 `map` 相同。

## Object.keys,values,entries

map.keys(),map.values(),map.entries()支持

- Map
- Set
- Array

普通对象也支持，但在语法上有一些不同。

### Object.keys,  values, entries

- Object.keys(obj) 返回一个包含该对象所有的键的数组。
- Object.values(obj) 返回一个包含该对象所有的值的数组。
- Object.entries(obj) 返回一个包含该对象所有[key,value]键值对的数组。

#### 对象方法与Map的区别

|          | Map        | Object                            |
| -------- | ---------- | --------------------------------- |
| 调用语法 | map.keys() | Object.keys(obj) 而不是obj.keys() |
| 返回值   | 可迭代项   | “真正的”数组                      |

- 为什么对象的调用语法不是obj.keys()?
  - 灵活性较大，对于自己创建的对象obj，可以实现自己的obj.keys()方法，同时仍然可以对它调用Object.keys(obj)方法。

- map.keys()的返回值为可迭代对象Iterable，而==**Object.keys()的返回值为数组。**==

#### Object.keys/values/entries 会忽略symbol属性

如for..in 循环一样，方法会忽略使用Symbol(…)作为键的属性。

##### 只返回Symbol类型的键

==Object.getOwnPropertySymbols==

也是返回一个数组。

##### 返回所有键

==Reflect.ownKeys(obj)==

### 转换对象为数组

使用 Object.entries(obj)从obj获取由键/值对组成的数组。

对该数组使用数组方法，例如map。

对结果数组使用Object.fromEntries(array)方法，转回对象。

例如，我们有一个带有价格的对象，并想将它们加倍：

```javascript
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // 转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```

如果只需要key/value其中一种，也可以使用Object.keys(obj).数组方法/values(obj).数组方法，因为该方法的返回值为数组。

或者转换为数组后传参时，传入[key,object]数组，以对数组的索引或值分开操作。

Object.entries(obj).reduce(sum,[key,value]=>sum+value,0);

## 解构赋值

可以将数组或对象拆包赋值给一系列变量。

### 数组解构

```js
let arr=["Ilya","Kantor"]
let [firstName,surname]=arr;
alert(firstName);//Ilya
alert(surname);//Kantor
```

与返回值为数组的函数结合使用，如split：

```js
let [firstName,surname] = "Ilya Kantor".split('');
```

数组本身没有被修改，相当于：

```js
let firstName=arr[0];
let surname=arr[1];
```

#### 忽略使用逗号的元素

数组中不想要的元素可以通过添加额外的逗号把它丢弃。

```javascript
// 不需要第二个元素
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
```

在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 `title` 变量。

数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）。

#### 等号右侧可以是任何可迭代对象

```js
let [a,b,c] = "abc"; // ["a", "b", "c"]
let [one,two,three] = new Set([1,2,3]);
```

#### 等号左侧可以使用任何可以被赋值的东西

比如一个对象的属性：

```javascript
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya
```

#### 与.entries()方法进行循环操作

**for(let [key,value] of Object.entries(obj))**

对于map对象：

```js
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for(let [key ,value] of user){
alert(`${key}:${value}`);
}
```

#### 🤩交换变量值的技巧

```js
let guest = "Jane";
let admin ="Pete";
[guest,admin]=[admin,guest];
alert(`${guest} ${admin}`);
```

创建了一个由两个变量组成的临时数组， 并且立即以交换了的顺序对其进行了解构。

**可以用这种方式交换两个以上的变量。**

#### 剩余的‘…’

如果不只是要获得第一个值，还要将后续的所有元素都收集起来，我们可以使用三个点“…”来再加一个参数接收“剩余的”元素。

```javascript
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// 请注意，`rest` 的类型是数组
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```

==**`rest` 的值就是数组中剩下的元素组成的数组。**==

#### 默认值

赋值语句中，变量数量多于数组中实际元素的数量，赋值不会报错，未赋值的变量被认为是undefined:

```javascript
let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
```

如果我们想要一个“默认”值给未赋值的变量，我们可以使用 `=` 来提供：

```javascript
// 默认值
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius（来自数组的值）
alert(surname); // Anonymous（默认值被使用了）
```

**默认值可以是更加复杂的表达式甚至可以是函数调用**，

这些表达式或函数只会在==**这个变量未被赋值**==的时候才会被计算。

举个例子，我们使用了 `prompt` 函数来提供两个默认值，但它只会在未被赋值的那个变量上进行调用：

```javascript
// 只会提示输入姓氏
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius（来自数组）
alert(surname); // 你输入的值
```

### 对象解构

基本语法是：

```javascript
let {var1, var2} = {var1:…, var2:…}
```

在等号右侧有一个已经存在的对象，我们想把它拆开到变量中。等号左侧需要是对象中的属性名，属性值会被赋值给对应的变量，所以左侧变量的顺序并不重要。

在简单的情况下，等号左侧的就是 `{...}` 中的变量名列表。

等号左侧的模式（pattern）可以更加复杂，并且指定了属性和变量之间的映射关系。

如果想把一个属性赋值给另一个名字的变量，可以用冒号来指定：

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w=100, height: h=200, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

对于可能缺失的属性，使用“=”设置默认值。

就像数组或函数参数一样，默认值可以是任意表达式甚至是函数调用，它们只会在未提供对应的值时才会被计算/调用。

#### 剩余模式（pattern）“…”

当对象拥有的属性数量比我们提供的变量数量还多，我们可以使用剩余模式（pattern）只取其中的某一些属性，然后把剩余的赋值到其他地方，就像我们对数组那样。一些较旧的浏览器不支持此功能（例如，使用 Babel 对其进行填充），但可以在现代浏览器中使用。

```javascript
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = 名为 title 的属性
// rest = 存有剩余属性的对象
let {title, ...rest} = options;

// 现在 title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
```

…rest的结果为一个对象。

##### 不使用let时的陷阱

```js
{title,width,height}={title: "Menu", width: 200, height: 100};
```

**js会将主代码流中（即不在其他表达式中）的{…}当做一个代码块**，所以此时会报错。

可以通过把整个赋值表达式用括号括起来解决。

```javascript
let title, width, height;

// 现在就可以了
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
```

### 嵌套解构

如果一个对象或数组嵌套了其他的对象或数组，可以在等号左侧使用更复杂的模式来提取更深层的数据。

```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// 为了清晰起见，解构赋值语句被写成多行的形式
let {
  size: { // 把 size 赋值到这里
    width,
    height
  },
  items: [item1, item2], // 把 items 赋值到这里
  title = "Menu" // 在对象中不存在（使用默认值）
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut	
```

**size 和 item 没有对应的变量，我们只取了他们的内容**

### 智能函数参数

当函数的参数过多时，可以将所有的参数当作一个对象来传递，在函数接收参数时将对象解构为多个变量。

```js
// 我们传递一个对象给函数
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ……然后函数马上把对象展开成变量
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – 提取于 options，
  // width, height – 使用默认值
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
```

**这种解构假定了showMenu()函数确实存在参数。**

如果我们想让所有的参数都使用默认值，那我们应该传递一个==空对象==。不传参会导致错误。

我们也可以通过**指定空对象{}为整个参数对象的默认值**来解决这个问题：

function showMenu({title:"Menu",width=100,height=200}==**={}**==){
	...
}

## 日期和时间

### 创建

- **new Date()** //Fri Sep 03 2021 12:49:02 GMT+0800 

- **new Date(timestamp) **通过时间戳来创建日期

  - **new Date(0)** 0表示01.01.1970 UTC+0
  - **new Date(24*3600\*1000)** 增加24个小时，得到02.01.1970 UTC+0
  - **传入的整数参数**代表的是自1970-01-01 00:00:00以来经过的毫秒数，该整数被称为**时间戳**。
  - 传入负数可以得到01.01.1970之前的日期。

- **new Date(datestring)** 如果只有 **一个参数** 并且是 **字符串** 那么它会被自动解析。

  - 该算法与 ==**Date.parse**== 所使用的算法相同。
  - let date = new Date(“2017-01-26”);
  - 如果时间没有设定 会被假定为格林尼治标准时间（GMT）的午夜，并根据你运行代码时的时区进行调整。

- **new Date(year, month, date, hours, minutes, seconds, ms)** 使用当前时区中的给定组件创建日期。

  - ==只有前两个参数是必须的==

  - year必须是四位数

  - month计数从 **0** （一月）开始，到 **11**（十二月）结束。

  - date是当月的具体某一天，如果缺失，则为默认值 1。

  - 如果 hours / minutes / seconds / ms 缺失，则均为默认值0。

    - 例如：

    ```javascript
    new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
    new Date(2011, 0, 1); // 同样，时分秒等均为默认值 0
    ```

    时间度量最大精确到 1 毫秒（1/1000 秒）：

    ```javascript
    let date = new Date(2011, 0, 1, 2, 3, 4, 567);
    alert( date ); // 1.01.2011, 02:03:04.567
    ```

### 访问日期组件

以下所有的方法返回的组件都是基于当地时区的：

- **getFullYear()** 获取4位数年份
- **getMonth()** 获取月份，==**从0到11**==。
- **getDate()** 获取当月的具体日期，从1到31。
- **getHours()，getMinutes()，getSeconds()，getMilliseconds()** 获取相应的时间组件。
- **getDay()** 获取一周中的第几天，从 0（星期日）到 6 （星期六）。第一天始终是星期日。

很多JavaScript引擎都实现了一个非标准化的方法 getYear()。不推荐使用这个方法。有时候可能会返回2位的年份信息。

也有与当地时区的UTC对应项，它们会返回UTC+0时区的日期：**getUTCFullYear()**，**getUTCMonth()**，**getUTCDay()**

除了上述给定的方法，还有两个没有UTC变体的特殊方法：

- **getTime()** 返回日期的时间戳
- **getTimezoneOffset()** 返回UTC与本地时区之间的时差，以==**分钟**==为单位。

### 设置日期组件

- setFullYear(year,[month],[date])
- setMonth(month,[date])
- setDate(date)
- setHours(hour,[min],[sec],[ms])
- setMinutes(min,[sec],[ms])
- setSeconds(sec,[ms])
- setMilliseconds(ms)
- setTime(milliseconds) **使用时间戳来设置整个日期**

除了setTime外都有UTC变体，如setUTCHours()。

一些方法可以一次性设置多个组件，未提及的组件不会被修改。

### 自动校准 Autocorrection

自动校准是Date对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。

```javascript
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ……是 1st Feb 2013!
```

超出范围的日期组件将会被自动分配。

**==假设要在日期上进行加减一些天数==**，Date对象可以处理：

```js
let date = new Date(2016, 1, 28);
date.setDate(date.getDate()+-n);
```

可以用于获取给定时间段后的日期。

```js
date.setDate(1);//设置为当月第一天
date.setDate(0);//设置为上月的最后一天
```

### 日期转化为数字，日期差值

当Date对象被转化为数字时，得到的是对应的时间戳，与使用**date.getTime()**的结果相同。

```js
let date = new Date();
alert(+date);
```

因此日期可以相减，结果是以毫秒为单位的时间差。

可以用于时间测量：

```js
let start = new Date();

for(let i=0; i < 100000; i++){
	let doSomething = i * i * i;
}
let end = new Date();

alert(`The loop took ${end - start} ms`);
```

### Date.now()

仅仅测量时间间隔，不需要Date对象，有一个特殊的方法。

Date.now()，它会返回当前的时间戳。

相当于 new Date().getTime() , 但它不会创建中间的Date对象。因此更快，而且不会对垃圾处理造成额外的压力。

### 😫🥱度量 Benchmarking

### 对一个字符串使用 Date.parse

Date.parse(str)方法可以从一个字符串中读取日期。

字符串的格式应该为：==**YYYY-MM-DDTHH:mm:ss.sssZ**==

- 字符‘T’为分隔符,可以是除了‘-’的其他字符
- 可选字符‘Z’ 为==**+-hh:mm**== 格式的时区。单个字符Z 代表UTC+0 时区。

简短形式也是可以的，比如YYYY-MM-DD 或 YYYY-MM，甚至YYYY

Date.parse(str)调用会解析给定格式的字符串，并返回时间戳，如果给定字符串的格式不正确，则返回NaN。

有时需要更加精准的时间度量，JavaScript自身并没有测量微秒的方法，但大多数运行环境会提供。例如：

浏览器有 **performance.now()** 来给出从页面加载开始的以毫秒为单位的微毫秒，

**精确到毫秒的小数点后三位，小数点后超过三位的数字时精度错误**。

### 创建日期

new Date(2012,2,20,3,15);

new Date(“Feb 20, 2012 03:15:00”);

### 某月的最后一天

```js
function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}
```

### 格式化相对日期

以 `"DD.MM.YY HH:mm"` 格式输出完整日期。

```js
let d=date;
d=[
'0'+d.getDate(),
'0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component => component.slice(-2)); // 得到每个组件的后两位
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
```

