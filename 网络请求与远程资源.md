## Ajax 

- 异步的 JavaScript + XML。
- 异步地从服务器获取额外数据而无需刷新页面

### 实现使用的技术

- 在 XHR 之前为黑科技：隐藏 / 内嵌窗格
- XMLHttpRequest 对象
  - 为发送服务器请求和获取相应提供了合理的接口
  - 数据格式不一定为 XML
  - 提供了原生的浏览器通信能力

### XMLHttpRequest 对象

#### 创建 XHR 对象

所有现代浏览器都通过 XMLHttpRequest 构造函数 原生支持 XHR 对象。

```js
var xhr = new XMLHttpRequest();
```

#### 准备请求

`xhr.open(请求类型, 请求url, 是否为异步请求的布尔值)` 

- 请求类型：get / post / …
- 请求url：只能使用**同源 url**

```js
xhr.open('get','example.php', false)
```

#### 发送请求

`xhr.send(必需的请求体内容)`

- 如果没有请求体，则参数应为 null
- **若请求为同步类型，则 JavaScript 线程会被阻塞，直至收到响应**

```js
xhr.send(null);
```

#### 处理响应

收到响应后，xhr 对象的一些属性会被填充：

- `responseText`:响应体文本 / 错误消息
- `responseXML`：只有当响应内容类型为 `text/xml` `application/xml` 时，才为包含响应数据的 XML DOM 文档
- `status`：响应 HTTP 状态码
  - 为 200 ~ 299 表示成功
  - 为 304 表示资源未修改过，是从浏览器缓存中直接拿取的。
- `statusText`：响应 HTTP 状态描述
  - 在跨浏览器的情况下**不可靠**

xhr 对象有一个 `readyState` 属性，表示当前处在 请求 / 响应 的哪个阶段

- 0 未初始化（Uninitialized），尚未调用 `open()` 方法。
- 1 已打开（Open），已调用 `open() `方法，尚未调用 `send() `方法
- 2 已发送（Sent），已调用 `send()` 方法，尚未收到响应。
- 3 接收中（Receiving），已经收到部分响应。
- 4 完成（Complete），已经收到所有响应。

`readyState` 每次更改都会触发 `readystatechange` 事件。

为**保证跨浏览器兼容**

-  `onreadystatechange` 事件处理程序应该在调用 `open()` 之前赋值。
- 因为 `onreadystatechange` 事件处理程序的作用域问题，应使用 xhr 对象而不是 this，否则可能会导致错误。
- 以下代码使用 DOM Level 0 风格
  - DOM Level 0 :
    - onEvent = function() 
    - 在标签中定义事件回调，onEvent 属性值此时为 包装 事件处理程序属性值 的函数
  - DOM Level 2:
    - `addEventListener(‘event’,callback)`

```js
let xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
	if(xhr.readyState == 4){
		if(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){
			...
			xhr.responseText
		} else {
			xhr.status
		}
	}
	xhr.open("get","example.txt",true)
	xhr.send(null);
}
```

#### 取消异步请求

使用 `abort()` 方法：

- xhr 对象会**停止触发事件**
- 阻止访问这个对象上任何与 **响应** 相关的属性。

```js
xhr.abort()
```

中断请求后，应当取消对 xhr 对象的引用。

### 缺陷

1. 操作较复杂，API 不好用
2. 存在 **内存** 问题，不推荐重用 XHR。

### Http 头部

 

## Fetch

支持 Promise 风格和服务线程



